[
    {
        "id": 1,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Bubble Sort?",
        "options": [
            "Bubble Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Bubble Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 2,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Bubble Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Bubble Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 3,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Bubble Sort?",
        "options": [
            "O(n^2)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Typically, Bubble Sort has an average case of O(n^2)."
    },
    {
        "id": 4,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Bubble Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Bubble Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 5,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Bubble Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Bubble Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 6,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Hard",
        "question": "What makes Bubble Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Bubble Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 7,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Selection Sort?",
        "options": [
            "Selection Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Selection Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 8,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Selection Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Selection Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 9,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Selection Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Selection Sort has an average case of O(n^2)."
    },
    {
        "id": 10,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Selection Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Selection Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 11,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Selection Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Selection Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 12,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Hard",
        "question": "What makes Selection Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Selection Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 13,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Insertion Sort?",
        "options": [
            "Insertion Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Insertion Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 14,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Insertion Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Insertion Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 15,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Insertion Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(n^2)"
        ],
        "correctAnswer": 3,
        "explanation": "Typically, Insertion Sort has an average case of O(n^2)."
    },
    {
        "id": 16,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Insertion Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Insertion Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 17,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Insertion Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Insertion Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 18,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Hard",
        "question": "What makes Insertion Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Insertion Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 19,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Merge Sort?",
        "options": [
            "Merge Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Merge Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 20,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Merge Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Merge Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 21,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Merge Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Merge Sort has an average case of O(n log n)."
    },
    {
        "id": 22,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Merge Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Merge Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 23,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Merge Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "Merge Sort requires O(n) extra space in the worst case."
    },
    {
        "id": 24,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Hard",
        "question": "What makes Merge Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Merge Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 25,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Quick Sort?",
        "options": [
            "Quick Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Quick Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 26,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Quick Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "In the best case, Quick Sort can often achieve O(n log n), especially when data is already partially structured."
    },
    {
        "id": 27,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Quick Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Quick Sort has an average case of O(n log n)."
    },
    {
        "id": 28,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Quick Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Quick Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 29,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Quick Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Quick Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 30,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Hard",
        "question": "What makes Quick Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Quick Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 31,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Tim Sort?",
        "options": [
            "Tim Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Tim Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 32,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Tim Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Tim Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 33,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Tim Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Tim Sort has an average case of O(n log n)."
    },
    {
        "id": 34,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Tim Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Tim Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 35,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Tim Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Tim Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 36,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Hard",
        "question": "What makes Tim Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Tim Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 37,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Intro Sort?",
        "options": [
            "Intro Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Intro Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 38,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Intro Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "In the best case, Intro Sort can often achieve O(n log n), especially when data is already partially structured."
    },
    {
        "id": 39,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Intro Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Intro Sort has an average case of O(n log n)."
    },
    {
        "id": 40,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Intro Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Intro Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 41,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Intro Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Intro Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 42,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Hard",
        "question": "What makes Intro Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Intro Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 43,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Shell Sort?",
        "options": [
            "Shell Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Shell Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    { 
        "id": 44,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Shell Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "In the best case, Shell Sort can often achieve O(n log n), especially when data is already partially structured."
    },
    {
        "id": 45,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Shell Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Shell Sort has an average case of O(n log n)."
    },
    {
        "id": 46,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Shell Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Shell Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 47,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Shell Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Shell Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 48,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Hard",
        "question": "What makes Shell Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Shell Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 49,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Easy",
        "question": "What is the basic idea of Linear Search?",
        "options": [
            "Linear Search compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Linear Search is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 50,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Linear Search?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "In the best case, Linear Search can often achieve O(1), especially when target is the first element in array."
    },
    {
        "id": 51,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Linear Search?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Typically, Linear Search has an average case of O(n)."
    },
    {
        "id": 52,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Linear Search?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Linear Search usually works directly on arrays in basic implementations."
    },
    {
        "id": 53,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Hard",
        "question": "What is the worst case time complexity of Linear Search?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "Linear Search takes O(n) time to search through the entire array in the worst case."
    },
    {
        "id": 54,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Hard",
        "question": "What makes Linear Search less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Linear Search is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 55,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Easy",
        "question": "What is the basic idea of Binary Search?",
        "options": [
            "Binary Search compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Search is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 56,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Binary Search?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "In the best case, Binary Search can often achieve O(1), especially when data is already partially structured."
    },
    {
        "id": 57,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Binary Search?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 3,
        "explanation": "Typically, Binary Search has an average case of O(log n)."
    },
    {
        "id": 58,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Binary Search?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Search usually works directly on arrays in basic implementations."
    },
    {
        "id": 59,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Binary Search?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "Binary Search requires O(log n) time complexity in the worst case."
    },
    {
        "id": 60,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Hard",
        "question": "What makes Binary Search less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Binary Search is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    
  {
    "id": 67,
    "topic": "Searching",
    "algorithm": "Search in Databases",
    "difficulty": "Hard",
    "question": "Which searching technique is typically used in databases to speed up retrieval?",
    "options": [
      "Linear Search",
      "Binary Search",
      "Indexing with B-trees or Hashing",
      "Graph Search"
    ],
    "correctAnswer": 2,
    "explanation": "Databases use indexing techniques like B-trees and hashing to allow fast retrieval of records based on keys."
  },
  {
    "id": 68,
    "topic": "Searching",
    "algorithm": "File Systems",
    "difficulty": "Hard",
    "question": "How do modern file systems optimize search for files by name?",
    "options": [
      "Using Trie-based indexing",
      "Using Linear Search on all files",
      "Storing filenames in a queue",
      "Performing BFS on disk blocks"
    ],
    "correctAnswer": 0,
    "explanation": "Many modern file systems use Trie-like or hash-based structures to optimize filename lookups, especially for autocomplete and path resolution."
  },
  {
    "id": 69,
    "topic": "Searching",
    "algorithm": "Search Engines",
    "difficulty": "Hard",
    "question": "Which data structure is heavily used in search engines to map keywords to documents?",
    "options": [
      "Linked List",
      "Hash Table",
      "Inverted Index",
      "Binary Heap"
    ],
    "correctAnswer": 2,
    "explanation": "Search engines use an inverted index, which maps keywords to the list of documents containing them, allowing fast keyword-based retrieval."
  },
  {
    "id": 70,
    "topic": "Searching",
    "algorithm": "Pattern Matching",
    "difficulty": "Hard",
    "question": "Which algorithm is commonly used for efficient substring search in large texts?",
    "options": [
      "Linear Search",
      "KMP Algorithm",
      "Quick Sort",
      "Depth First Search"
    ],
    "correctAnswer": 1,
    "explanation": "The Knuth-Morris-Pratt (KMP) algorithm preprocesses the pattern and performs efficient substring search without backtracking."
  },
  {
    "id": 71,
    "topic": "Searching",
    "algorithm": "Networking",
    "difficulty": "Hard",
    "question": "In routing tables, which searching technique is used to determine the best path?",
    "options": [
      "Linear Search through all routes",
      "Longest Prefix Match using Trie",
      "Depth-First Search",
      "Interpolation Search"
    ],
    "correctAnswer": 1,
    "explanation": "Routers use Longest Prefix Match, often implemented using a Trie, to find the most specific matching route in the routing table."
  },
  {
    "id": 72,
    "topic": "Searching",
    "algorithm": "Operating Systems",
    "difficulty": "Hard",
    "question": "How does an operating system quickly find a process in a process table?",
    "options": [
      "Using a sorted array with Binary Search",
      "Using a Hash Table for constant-time lookup",
      "Using Breadth First Search",
      "Using Exponential Search"
    ],
    "correctAnswer": 1,
    "explanation": "Most operating systems use hash tables to store and search for processes efficiently by process ID."
  },


{
    "id":78,
    "topic": "Searching",
    "algorithm": "Search in Graphs",
    "difficulty": "Hard",
    "question": "Which search algorithm is best suited for finding the shortest path in an unweighted graph?",
    "options": [
      "Depth First Search (DFS)",
      "Breadth First Search (BFS)",     
        "Dijkstra's Algorithm",
        "A* Search"
    ],
    "correctAnswer": 1,
    "explanation": "BFS is optimal for finding the shortest path in unweighted graphs as it explores all neighbors level by level." 
},
  {
    "id": 79,
    "topic": "Searching",
    "algorithm": "Linear Search",
    "difficulty": "Medium",
    "question": "Which of the following is the correct implementation of Linear Search in Python?",
    "options": [
      "def linear_search(arr, x):\n    for i in arr:\n        if arr[i] == x:\n            return i\n    return -1",
      "def linear_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1",
      "def linear_search(arr, x):\n    if x in arr:\n        return x\n    return -1",
      "def linear_search(arr, x):\n    return arr.index(x)"
    ],
    "correctAnswer": 1,
    "explanation": "Option 2 is the correct implementation using index-based iteration. Option 1 has a bug; 'i' is the element, not index."
  },
  {
    "id": 80,
    "topic": "Searching",
    "algorithm": "Binary Search",
    "difficulty": "Medium",
    "question": "Which of the following correctly implements Binary Search (iterative)?",
    "options": [
      "def binary_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1",
      "def binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1",
      "def binary_search(arr, x):\n    arr.sort()\n    return arr.index(x)",
      "def binary_search(arr, x):\n    return arr.find(x)"
    ],
    "correctAnswer": 1,
    "explanation": "Option 2 is the correct iterative Binary Search implementation. It requires the array to be sorted beforehand."
  },
{
    "id": 73,
    "topic": "Searching",
    "algorithm": "Linear Search",
    "difficulty": "Medium",
    "question": "In an unsorted array, what is the average number of comparisons Linear Search will make to find a target element?",
    "options": [
      "n/2",
      "n",
      "log n",
      "1"
    ],
    "correctAnswer": 0,
    "explanation": "On average, Linear Search will traverse about half of the elements to find the target, resulting in n/2 comparisons."
  },
  {
    "id": 81,
    "topic": "Searching",
    "algorithm": "Recursive Binary Search",
    "difficulty": "Medium",
    "question": "Which code snippet correctly implements Recursive Binary Search?",
    "options": [
      "def binary_search(arr, x):\n    mid = len(arr) // 2\n    if arr[mid] == x:\n        return mid\n    elif x < arr[mid]:\n        return binary_search(arr[:mid], x)\n    else:\n        return binary_search(arr[mid+1:], x)",
      "def binary_search(arr, x, low, high):\n    if low > high:\n        return -1\n    mid = (low + high) // 2\n    if arr[mid] == x:\n        return mid\n    elif arr[mid] > x:\n        return binary_search(arr, x, low, mid - 1)\n    else:\n        return binary_search(arr, x, mid + 1, high)",
      "def binary_search(arr, x):\n    return arr.index(x)",
      "def binary_search(arr, x, low, high):\n    return (low + high) // 2 if x in arr else -1"
    ],
    "correctAnswer": 1,
    "explanation": "Option 2 shows a correct recursive Binary Search using `low` and `high` pointers. Option 1 is close but inefficient due to slicing."
  },
  
  {
    "id": 83,
    "topic": "Searching",
    "algorithm": "Hash Table Lookup",
    "difficulty": "Medium",
    "question": "Which of the following is a correct way to search in a hash table (dictionary) in Python?",
    "options": [
      "if key in dict:\n    return dict[key]",
      "if dict.has_key(key):\n    return dict[key]",
      "if dict[key]:\n    return key",
      "dict.get(key)"
    ],
    "correctAnswer": 0,
    "explanation": "Using `key in dict` is the Pythonic and safe way to check existence before access. Option 2 uses deprecated syntax."
  },
  {
    "id": 84,
    "topic": "Searching",
    "algorithm": "Ternary Search",
    "difficulty": "Medium",
    "question": "Which of the following correctly divides the array in Ternary Search?",
    "options": [
      "mid = (low + high) // 2",
      "mid1 = low + (high - low) // 2\nmid2 = mid1 + 1",
      "mid1 = low + (high - low) // 3\nmid2 = high - (high - low) // 3",
      "mid1 = (low + high) // 3\nmid2 = 2 * mid1"
    ],
    "correctAnswer": 2,
    "explanation": "Ternary Search divides the array into three parts using `mid1 = low + (high - low)/3` and `mid2 = high - (high - low)/3`."
  }
,


    {
        "id": 61,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Easy",
        "question": "What is the basic idea of Linked List?",
        "options": [
            "A linear data structure where elements (nodes) are connected using pointers.",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Each node contains data and a reference (link) to the next node, allowing dynamic memory allocation and easy insertion or deletion."
    },
    {
        "id": 62,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Linked List?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "In the best case, Linked List can often achieve O(1), especially for insertion/deletion at head"
    },
    {
        "id": 63,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Linked List?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Linked List has an average case of O(n\u00b2)."
    },
    {
        "id": 64,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Linked List?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Linked List usually works directly on arrays in basic implementations."
    },
    {
        "id": 65,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Linked List?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Linked List requires O(1) extra space in the worst case."
    },
    {
        "id": 66,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Hard",
        "question": "What makes Linked List less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Linked List is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 67,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Easy",
        "question": "What is the basic idea of Stack?",
        "options": [
            "A linear data structure that follows the LIFO (Last In, First Out) principle.",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Stack follows LIFO — the last element added is the first to be removed."
    },
    {
        "id": 68,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Stack?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "In the best case, Stack can often achieve O(1), especially for push/pop operations."
    },
    {
        "id": 69,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Stack?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Stack has an average case of O(n\u00b2)."
    },
    {
        "id": 70,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Stack?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Stack usually works directly on arrays in basic implementations."
    },
    {
        "id": 71,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Stack?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Stack requires O(1) extra space in the worst case."
    },
    {
        "id": 72,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Hard",
        "question": "What makes Stack less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Stack is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 73,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Easy",
        "question": "What is the basic idea of Queue?",
        "options": [
            "A linear data structure that follows the FIFO (First In, First Out) principle.",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Queue follows FIFO — the first element added is the first to be removed"
    },
    {
        "id": 74,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Queue?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "In the best case, Queue can often achieve O(1), especially for enqueue/dequeue operations"
    },
    {
        "id": 75,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Queue?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Queue has an average case of O(n\u00b2)."
    },
    {
        "id": 76,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Queue?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Queue usually works directly on arrays in basic implementations."
    },
    {
        "id": 77,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Queue?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Queue requires O(1) extra space in the worst case."
    },
    {
        "id": 78,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Hard",
        "question": "What makes Queue less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Queue is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 79,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Easy",
        "question": "What is the basic idea of Binary Tree?",
        "options": [
            "A hierarchical data structure in which each node has at most two children — a left and a right child.",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Tree organizes data hierarchically, where each node can have up to two children."
    },
    {
        "id": 80,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Binary Tree?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Binary Tree can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 81,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Binary Tree?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Binary Tree has an average case of O(n\u00b2)."
    },
    {
        "id": 82,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Binary Tree?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Tree usually works directly on arrays in basic implementations."
    },
    {
        "id": 83,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Binary Tree?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "Binary Tree requires O(n) extra space in the worst case."
    },
    {
        "id": 84,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Hard",
        "question": "What makes Binary Tree less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Binary Tree is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    
    {
        "id": 85,
        "topic": "Other Topics",
        "algorithm": "Hashing",
        "difficulty": "Easy",
        "question": "What is the primary goal of a hash function?",
        "options": [
            "To sort elements efficiently",
            "To map keys to indices for fast lookup",
            "To store data sequentially",
            "To compress data"
        ],
        "correctAnswer": 1,
        "explanation": "A hash function converts a key into an index for quick insertion, deletion, and retrieval in a hash table."
    },
    {
        "id": 86,
        "topic": "Other Topics",
        "algorithm": "Hashing",
        "difficulty": "Easy",
        "question": "Which data structure relies heavily on hashing for average O(1) access?",
        "options": [
            "Linked List",
            "Hash Table",
            "Stack",
            "Queue"
        ],
        "correctAnswer": 1,
        "explanation": "Hash tables use hashing to map keys to indices, allowing constant-time access on average."
    },
    {
        "id": 87,
        "topic": "Other Topics",
        "algorithm": "Hashing",
        "difficulty": "Medium",
        "question": "Which of these is a common collision resolution method?",
        "options": [
            "Chaining",
            "Merge Sort",
            "Binary Search",
            "Heapify"
        ],
        "correctAnswer": 0,
        "explanation": "Chaining handles collisions by storing multiple items in a linked list at the same hash index."
    },
    {
        "id": 88,
        "topic": "Other Topics",
        "algorithm": "Hashing",
        "difficulty": "Medium",
        "question": "What is a characteristic of a good hash function?",
        "options": [
            "Minimizes collisions and distributes keys uniformly",
            "Always returns 0",
            "Sorts keys automatically",
            "Uses a linked list internally"
        ],
        "correctAnswer": 0,
        "explanation": "A good hash function reduces collisions and spreads keys evenly across the table."
    },
    {
        "id": 89,
        "topic": "Other Topics",
        "algorithm": "Hashing",
        "difficulty": "Hard",
        "question": "What is the worst-case time complexity for search in a hash table with chaining?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n log n)"
        ],
        "correctAnswer": 2,
        "explanation": "In the worst case, all keys may collide to the same index, creating a list of n elements and O(n) search."
    },
    {
        "id": 90,
        "topic": "Other Topics",
        "algorithm": "Hashing",
        "difficulty": "Hard",
        "question": "Which factor affects hash table performance the most?",
        "options": [
            "Load factor",
            "Hash function quality",
            "Collision resolution technique",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "All of these factors influence how efficiently a hash table operates."
    },
    {
        "id": 91,
        "topic": "Other Topics",
        "algorithm": "Tree",
        "difficulty": "Easy",
        "question": "What is the key property of a binary search tree (BST)?",
        "options": [
            "All nodes have two children",
            "Left child < parent < right child",
            "All leaves are at the same level",
            "Tree is balanced automatically"
        ],
        "correctAnswer": 1,
        "explanation": "In a BST, the left child is smaller than the parent, and the right child is larger, facilitating efficient search."
    },
    {
        "id": 92,
        "topic": "Other Topics",
        "algorithm": "Tree",
        "difficulty": "Easy",
        "question": "Which traversal visits nodes in left-root-right order?",
        "options": [
            "Preorder",
            "Inorder",
            "Postorder",
            "Level-order"
        ],
        "correctAnswer": 1,
        "explanation": "Inorder traversal visits nodes in left, root, right order."
    },
    {
        "id": 93,
        "topic": "Other Topics",
        "algorithm": "Tree",
        "difficulty": "Medium",
        "question": "What is the height of a perfectly balanced binary tree with n nodes?",
        "options": [
            "O(n)",
            "O(log n)",
            "O(n^2)",
            "O(1)"
        ],
        "correctAnswer": 1,
        "explanation": "A perfectly balanced binary tree has height proportional to log(n)."
    },
    {
        "id": 94,
        "topic": "Other Topics",
        "algorithm": "Tree",
        "difficulty": "Medium",
        "question": "Which tree is used for efficient priority queue operations?",
        "options": [
            "Binary Search Tree",
            "Heap",
            "Trie",
            "AVL Tree"
        ],
        "correctAnswer": 1,
        "explanation": "Heaps allow efficient insertions and extraction of the maximum or minimum element."
    },
    {
        "id": 95,
        "topic": "Other Topics",
        "algorithm": "Tree",
        "difficulty": "Hard",
        "question": "Which self-balancing tree guarantees O(log n) search, insert, and delete?",
        "options": [
            "Binary Search Tree",
            "AVL Tree",
            "Heap",
            "Trie"
        ],
        "correctAnswer": 1,
        "explanation": "AVL trees maintain height balance, ensuring logarithmic time complexity for basic operations."
    },
    {
        "id": 96,
        "topic": "Other Topics",
        "algorithm": "Tree",
        "difficulty": "Hard",
        "question": "What is the time complexity to find the lowest common ancestor in a BST?",
        "options": [
            "O(n)",
            "O(log n)",
            "O(n log n)",
            "O(1)"
        ],
        "correctAnswer": 1,
        "explanation": "In a balanced BST, LCA can be found in O(log n) by traversing from the root."
    },
    {
        "id": 97,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Knapsack 01",
        "difficulty": "Easy",
        "question": "In 0/1 Knapsack, what does each node in the decision tree represent?",
        "options": [
            "A fraction of items chosen",
            "A subset of items with binary choice",
            "Sorted order of items",
            "Maximum weight used"
        ],
        "correctAnswer": 1,
        "explanation": "Each node represents including or excluding an item in the knapsack."
    },
    {
        "id": 98,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Knapsack 01",
        "difficulty": "Easy",
        "question": "What is the purpose of bounding in Branch & Bound?",
        "options": [
            "To prune branches that cannot improve solution",
            "To sort nodes",
            "To calculate weight only",
            "To list all subsets"
        ],
        "correctAnswer": 0,
        "explanation": "Bounding estimates the maximum possible value from a node to decide whether to explore it."
    },
    {
        "id": 99,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Knapsack 01",
        "difficulty": "Medium",
        "question": "Which method provides an upper bound for 0/1 Knapsack?",
        "options": [
            "Fractional Knapsack solution",
            "Binary search",
            "DFS traversal",
            "Random selection"
        ],
        "correctAnswer": 0,
        "explanation": "Fractional knapsack gives an optimistic estimate for remaining items."
    },
    {
        "id": 100,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Knapsack 01",
        "difficulty": "Medium",
        "question": "What is the worst-case complexity of Branch & Bound for Knapsack?",
        "options": [
            "O(n^2)",
            "O(2^n)",
            "O(n log n)",
            "O(n)"
        ],
        "correctAnswer": 1,
        "explanation": "In worst case, Branch & Bound explores all subsets, which is exponential."
    },
    {
        "id": 101,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Traveling Salesman",
        "difficulty": "Easy",
        "question": "What is the main goal of TSP Branch & Bound?",
        "options": [
            "Shortest tour visiting all cities once",
            "Longest tour",
            "Random tour selection",
            "Counting cities"
        ],
        "correctAnswer": 0,
        "explanation": "Branch & Bound finds the minimum-cost tour covering all cities exactly once."
    },
    {
        "id": 102,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Traveling Salesman",
        "difficulty": "Easy",
        "question": "What does a lower bound represent in TSP Branch & Bound?",
        "options": [
            "Minimum possible cost to complete partial tour",
            "Maximum cost tour",
            "Number of cities visited",
            "Average edge weight"
        ],
        "correctAnswer": 0,
        "explanation": "Lower bound helps prune paths that cannot yield a better solution."
    },
    {
        "id": 103,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Traveling Salesman",
        "difficulty": "Medium",
        "question": "How does the reduced cost matrix help in TSP?",
        "options": [
            "Provides tighter lower bounds",
            "Increases distances",
            "Counts cities",
            "Maximizes cost"
        ],
        "correctAnswer": 0,
        "explanation": "Reduced cost matrix improves pruning efficiency by giving better lower bounds."
    },
    {
        "id": 104,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Traveling Salesman",
        "difficulty": "Medium",
        "question": "How are subtours eliminated in TSP Branch & Bound?",
        "options": [
            "Maintaining a valid path and checking cycles",
            "Increasing edge costs",
            "Removing cities",
            "Random edge deletion"
        ],
        "correctAnswer": 0,
        "explanation": "Algorithm ensures no cycles form prematurely in the partial tour."
    },
    {
        "id": 105,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Traveling Salesman",
        "difficulty": "Hard",
        "question": "Which strategy is most effective for branching in TSP?",
        "options": [
            "Selecting minimum cost edges first",
            "Random edges",
            "Maximum cost edges",
            "Middle edges"
        ],
        "correctAnswer": 0,
        "explanation": "Choosing edges with minimum cost often leads to better solutions earlier."
    },
    {
        "id": 106,
        "topic": "Other Topics",
        "algorithm": "Branch & Bound: Traveling Salesman",
        "difficulty": "Hard",
        "question": "What makes TSP challenging for Branch & Bound?",
        "options": [
            "Combination of constraints and optimization",
            "Only number of cities",
            "Distance calculation",
            "Path finding"
        ],
        "correctAnswer": 0,
        "explanation": "TSP requires maintaining valid tours while optimizing total cost."
    },
    
    {
        "id": 107,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Easy",
        "question": "What is the main goal of the Minimax algorithm?",
        "options": [
            "Maximize player's minimum gain",
            "Minimize opponent's score",
            "Randomly choose moves",
            "Sort possible moves"
        ],
        "correctAnswer": 0,
        "explanation": "Minimax assumes both players play optimally and aims to maximize the minimum gain."
    },
    {
        "id": 108,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Easy",
        "question": "In a two-player game tree, what do leaf nodes represent in Minimax?",
        "options": [
            "Current board state",
            "Terminal game states with utility values",
            "Parent moves",
            "Next player’s moves"
        ],
        "correctAnswer": 1,
        "explanation": "Leaf nodes represent terminal states with assigned utility values for evaluation."
    },
    {
        "id": 109,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Medium",
        "question": "What is the time complexity of Minimax with depth d and branching factor b?",
        "options": [
            "O(b + d)",
            "O(b^d)",
            "O(d^b)",
            "O(b * d)"
        ],
        "correctAnswer": 1,
        "explanation": "Minimax explores all nodes in the tree, leading to O(b^d) complexity."
    },
    {
        "id": 110,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Medium",
        "question": "Which strategy does Minimax assume for the opponent?",
        "options": [
            "Optimal play to minimize our score",
            "Random moves",
            "Fixed moves",
            "Maximize our score"
        ],
        "correctAnswer": 0,
        "explanation": "Minimax assumes the opponent always plays optimally to minimize the player's gain."
    },
    {
        "id": 111,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Hard",
        "question": "How does Minimax handle non-deterministic games?",
        "options": [
            "It cannot handle them directly",
            "Uses probability for opponent moves",
            "Ignores randomness",
            "Assumes worst-case outcomes"
        ],
        "correctAnswer": 0,
        "explanation": "Minimax works for deterministic games; stochastic elements require Expectimax or similar."
    },
    {
        "id": 112,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Easy",
        "question": "What is the purpose of Alpha-Beta pruning?",
        "options": [
            "Reduce the number of nodes evaluated",
            "Increase branching factor",
            "Sort moves randomly",
            "Compute all leaf nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Alpha-Beta pruning eliminates branches that cannot influence the final decision, improving efficiency."
    },
    {
        "id": 113,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Easy",
        "question": "What do alpha and beta represent?",
        "options": [
            "Alpha: best max value, Beta: best min value",
            "Alpha: random number, Beta: score",
            "Alpha: min value, Beta: max value",
            "Alpha: branch factor, Beta: depth"
        ],
        "correctAnswer": 0,
        "explanation": "Alpha is the best value the maximizer can guarantee; beta is the best value the minimizer can guarantee."
    },
    {
        "id": 114,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Medium",
        "question": "What is the best-case time complexity of Alpha-Beta pruning?",
        "options": [
            "O(b^d)",
            "O(b^(d/2))",
            "O(d^b)",
            "O(b + d)"
        ],
        "correctAnswer": 1,
        "explanation": "With perfect move ordering, Alpha-Beta reduces nodes to O(b^(d/2)), roughly doubling depth capability."
    },
    {
        "id": 115,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Medium",
        "question": "Which factor affects the efficiency of Alpha-Beta pruning the most?",
        "options": [
            "Move ordering",
            "Branching factor",
            "Board size",
            "Number of leaf nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Good move ordering maximizes pruning and significantly reduces nodes evaluated."
    },
    {
        "id": 116,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Hard",
        "question": "Alpha-Beta pruning can prune a node if:",
        "options": [
            "Alpha >= Beta",
            "Alpha < Beta",
            "Node is a leaf",
            "Node has no children"
        ],
        "correctAnswer": 0,
        "explanation": "Pruning occurs when the best option for maximizer exceeds the minimizer's guaranteed value, i.e., alpha >= beta."
    },
    {
        "id": 117,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Easy",
        "question": "How does Expectimax differ from Minimax?",
        "options": [
            "It accounts for probabilistic outcomes",
            "It ignores opponent",
            "It only maximizes",
            "It randomly selects moves"
        ],
        "correctAnswer": 0,
        "explanation": "Expectimax handles stochastic games by using expected utility for chance nodes."
    },
    {
        "id": 118,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Medium",
        "question": "What do chance nodes represent in Expectimax?",
        "options": [
            "Random events with probabilities",
            "Maximizer moves",
            "Minimizer moves",
            "Terminal states"
        ],
        "correctAnswer": 0,
        "explanation": "Chance nodes model randomness, and their values are weighted averages of children."
    },
    {
        "id": 119,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Medium",
        "question": "What is the main drawback of Expectimax compared to Minimax?",
        "options": [
            "Higher computation due to probabilistic nodes",
            "Does not find optimal moves",
            "Only works for deterministic games",
            "Cannot handle trees"
        ],
        "correctAnswer": 0,
        "explanation": "Including chance nodes increases the number of evaluations, making Expectimax more expensive."
    },
    {
        "id": 120,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Easy",
        "question": "What is the main idea behind Monte Carlo Tree Search (MCTS)?",
        "options": [
            "Use random simulations to evaluate moves",
            "Prune branches like Alpha-Beta",
            "Compute exact values for all nodes",
            "Sort moves by heuristics only"
        ],
        "correctAnswer": 0,
        "explanation": "MCTS uses random playouts to estimate the value of moves, improving decision-making without full search."
    },
    {
        "id": 121,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Medium",
        "question": "Which phases are part of MCTS?",
        "options": [
            "Selection, Expansion, Simulation, Backpropagation",
            "Minimize, Maximize",
            "Random selection only",
            "Prune and sort"
        ],
        "correctAnswer": 0,
        "explanation": "MCTS follows four phases to select moves, simulate games, and update tree values."
    },
    {
        "id": 122,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Medium",
        "question": "What is the UCT formula used for in MCTS?",
        "options": [
            "Balance exploration and exploitation",
            "Sort moves alphabetically",
            "Compute exact probabilities",
            "Prune bad moves"
        ],
        "correctAnswer": 0,
        "explanation": "UCT guides selection in the tree to explore uncertain nodes while exploiting promising moves."
    },
    {
        "id": 123,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Hard",
        "question": "What is a major limitation of MCTS?",
        "options": [
            "May require many simulations for accurate estimates",
            "Cannot handle randomness",
            "Does not evaluate moves",
            "Only works for two-player games"
        ],
        "correctAnswer": 0,
        "explanation": "MCTS accuracy depends on the number of simulations; fewer simulations can lead to poor move choices."
    },
    {
        "id": 124,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Hard",
        "question": "Which game famously uses MCTS for AI decisions?",
        "options": [
            "Go",
            "Tic-Tac-Toe",
            "Connect Four",
            "Chess only"
        ],
        "correctAnswer": 0,
        "explanation": "MCTS was instrumental in AlphaGo's success by efficiently handling a huge search space in Go."
    },
    {
        "id": 125,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Hard",
        "question": "How can Minimax be optimized without pruning?",
        "options": [
            "Use depth-limited search",
            "Evaluate all nodes",
            "Randomize move order",
            "Ignore terminal states"
        ],
        "correctAnswer": 0,
        "explanation": "Depth-limited search evaluates only up to a certain depth, reducing computation."
    },
    {
        "id": 126,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Hard",
        "question": "In Minimax, what is the role of an evaluation function?",
        "options": [
            "Estimate utility at non-terminal nodes",
            "Sort moves alphabetically",
            "Select random moves",
            "Ignore game state"
        ],
        "correctAnswer": 0,
        "explanation": "Evaluation functions approximate the value of a board when terminal states are too far to compute."
    },
    {
        "id": 127,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Medium",
        "question": "What happens if move ordering is worst-case in Alpha-Beta?",
        "options": [
            "Pruning efficiency is reduced",
            "Algorithm fails",
            "Tree becomes smaller",
            "Explores only half nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Poor move ordering reduces pruning effectiveness; in worst-case, it evaluates nearly all nodes."
    },
    {
        "id": 128,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Hard",
        "question": "Which node is pruned first in Alpha-Beta pruning?",
        "options": [
            "Node that cannot improve parent value",
            "Leaf node with max value",
            "Root node",
            "Random node"
        ],
        "correctAnswer": 0,
        "explanation": "Nodes whose values cannot affect the outcome of parent nodes are pruned immediately."
    },
    {
        "id": 129,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Hard",
        "question": "In Expectimax, how are chance nodes calculated?",
        "options": [
            "Weighted average of child utilities",
            "Max of child values",
            "Min of child values",
            "Random selection"
        ],
        "correctAnswer": 0,
        "explanation": "Chance nodes use probability-weighted averages to account for stochastic events."
    },
    {
        "id": 130,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Medium",
        "question": "Expectimax is most useful in which type of games?",
        "options": [
            "Stochastic games",
            "Deterministic two-player games",
            "Single-player puzzle games",
            "Only board games"
        ],
        "correctAnswer": 0,
        "explanation": "Expectimax handles games with randomness, unlike deterministic Minimax."
    },
    {
        "id": 131,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Medium",
        "question": "During MCTS, what does the backpropagation step do?",
        "options": [
            "Updates node values based on simulation",
            "Expands child nodes",
            "Selects next node randomly",
            "Prunes bad moves"
        ],
        "correctAnswer": 0,
        "explanation": "Backpropagation updates the win/loss statistics of all nodes visited during the simulation."
    },
    {
        "id": 132,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Hard",
        "question": "Which parameter affects MCTS exploration vs exploitation?",
        "options": [
            "UCT constant",
            "Branching factor",
            "Tree depth",
            "Simulation count"
        ],
        "correctAnswer": 0,
        "explanation": "The UCT constant balances exploring unknown moves and exploiting known good moves."
    },
    {
        "id": 133,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Medium",
        "question": "Which of the following improves Minimax performance?",
        "options": [
            "Alpha-Beta pruning",
            "Random selection",
            "Depth increase",
            "Ignoring terminal nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Alpha-Beta pruning reduces the number of nodes Minimax evaluates."
    },
    {
        "id": 134,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Medium",
        "question": "If alpha equals beta at a node, what does it mean?",
        "options": [
            "Further exploration is useless; prune",
            "Continue searching children",
            "Randomly select a node",
            "Restart search"
        ],
        "correctAnswer": 0,
        "explanation": "Alpha >= Beta indicates no better value can be found; pruning is performed."
    },
    {
        "id": 135,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Hard",
        "question": "Which situation makes Expectimax more computationally expensive than Minimax?",
        "options": [
            "Presence of multiple chance nodes",
            "Small branching factor",
            "Shallow tree depth",
            "Deterministic opponent"
        ],
        "correctAnswer": 0,
        "explanation": "Chance nodes require evaluating expected values, increasing computations."
    },
    {
        "id": 136,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Hard",
        "question": "MCTS simulations help in games with:",
        "options": [
            "Huge branching factors and uncertain outcomes",
            "Small deterministic games only",
            "Chess only",
            "No randomness"
        ],
        "correctAnswer": 0,
        "explanation": "Random simulations allow handling large search spaces where full search is infeasible."
    },
    {
        "id": 137,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Easy",
        "question": "Who moves first in Minimax evaluation?",
        "options": [
            "Maximizer",
            "Minimizer",
            "Random player",
            "Chance node"
        ],
        "correctAnswer": 0,
        "explanation": "Evaluation starts from the maximizer’s move, assuming optimal opponent play."
    },
    {
        "id": 138,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Easy",
        "question": "Alpha-Beta pruning is a technique to:",
        "options": [
            "Optimize Minimax",
            "Randomize moves",
            "Increase tree depth",
            "Compute exact probabilities"
        ],
        "correctAnswer": 0,
        "explanation": "It reduces unnecessary node evaluations in Minimax without affecting correctness."
    },
    {
        "id": 139,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Easy",
        "question": "Expectimax evaluates which type of nodes besides max and min?",
        "options": [
            "Chance nodes",
            "Random nodes",
            "Terminal nodes only",
            "Heuristic nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Chance nodes handle randomness using expected values."
    },
    {
        "id": 140,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Easy",
        "question": "Which step in MCTS is responsible for exploring promising nodes?",
        "options": [
            "Selection",
            "Expansion",
            "Simulation",
            "Backpropagation"
        ],
        "correctAnswer": 0,
        "explanation": "Selection uses the tree policy to pick nodes that balance exploration and exploitation."
    },
    {
        "id": 141,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Medium",
        "question": "Minimax with depth limit can cause:",
        "options": [
            "Suboptimal decisions due to horizon effect",
            "Optimal decisions always",
            "Infinite loops",
            "Random moves"
        ],
        "correctAnswer": 0,
        "explanation": "Limited depth may miss consequences beyond the horizon, causing poor choices."
    },
    {
        "id": 142,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Hard",
        "question": "Which scenario leads to maximum pruning?",
        "options": [
            "Perfect move ordering",
            "Random ordering",
            "Single-node tree",
            "Shallow tree"
        ],
        "correctAnswer": 0,
        "explanation": "Visiting best moves first allows pruning large subtrees, reducing computation."
    },
    {
        "id": 143,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Medium",
        "question": "What does the Expectimax algorithm assume about the opponent?",
        "options": [
            "Random moves according to probabilities",
            "Optimal moves like Minimax",
            "Always loses",
            "No moves"
        ],
        "correctAnswer": 0,
        "explanation": "Opponent moves are modeled probabilistically in stochastic games."
    },
    {
        "id": 144,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Medium",
        "question": "What is the main advantage of MCTS over Minimax in large games?",
        "options": [
            "Handles huge search spaces with limited simulations",
            "Always finds exact best move",
            "Ignores chance nodes",
            "Prunes more efficiently"
        ],
        "correctAnswer": 0,
        "explanation": "MCTS can provide good move estimates without full tree search."
    },
    {
        "id": 145,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Hard",
        "question": "Which data structure is commonly used to implement Minimax?",
        "options": [
            "Tree",
            "Queue",
            "Stack only",
            "Graph"
        ],
        "correctAnswer": 0,
        "explanation": "A tree structure represents game states and moves for Minimax traversal."
    },
    {
        "id": 146,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Hard",
        "question": "Which node order minimizes the number of evaluations in Alpha-Beta?",
        "options": [
            "Nodes with best moves first",
            "Random order",
            "Worst moves first",
            "Leaf nodes only"
        ],
        "correctAnswer": 0,
        "explanation": "Evaluating best moves first maximizes pruning efficiency."
    },
    {
        "id": 147,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Medium",
        "question": "In Expectimax, what is the expected value used for?",
        "options": [
            "Choosing optimal move under uncertainty",
            "Pruning nodes",
            "Randomly selecting moves",
            "Ignoring chance nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Expected values allow optimal decisions when outcomes are probabilistic."
    },
    {
        "id": 148,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Hard",
        "question": "Which phase of MCTS is responsible for expanding the tree?",
        "options": [
            "Expansion",
            "Selection",
            "Simulation",
            "Backpropagation"
        ],
        "correctAnswer": 0,
        "explanation": "Expansion adds new child nodes to the tree for further simulations."
    },
    {
        "id": 149,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Medium",
        "question": "Minimax is guaranteed to find the optimal move if:",
        "options": [
            "The game is deterministic and fully observable",
            "Moves are random",
            "Opponent is weak",
            "Tree depth is limited"
        ],
        "correctAnswer": 0,
        "explanation": "Deterministic games with full information allow Minimax to guarantee optimal moves."
    },
    {
        "id": 150,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Medium",
        "question": "What happens if alpha > beta accidentally in Alpha-Beta?",
        "options": [
            "Pruning occurs",
            "Algorithm crashes",
            "Search restarts",
            "Nothing happens"
        ],
        "correctAnswer": 0,
        "explanation": "Pruning occurs whenever alpha >= beta, even if inequality arises unexpectedly."
    },
    {
        "id": 151,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Hard",
        "question": "Why is Expectimax not suitable for games with many chance nodes?",
        "options": [
            "Computationally expensive due to many expected value calculations",
            "Cannot handle deterministic games",
            "Always produces wrong moves",
            "Does not model opponents"
        ],
        "correctAnswer": 0,
        "explanation": "Multiple chance nodes increase evaluations exponentially, making Expectimax costly."
    },
    {
        "id": 152,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Medium",
        "question": "Which factor increases MCTS accuracy?",
        "options": [
            "Number of simulations",
            "Branching factor",
            "Tree depth",
            "Alpha value"
        ],
        "correctAnswer": 0,
        "explanation": "More simulations provide better statistical estimates for move evaluation."
    },
    {
        "id": 153,
        "topic": "Other Topics",
        "algorithm": "Game Search: Monte Carlo Tree Search",
        "difficulty": "Hard",
        "question": "Which of the following is a limitation of MCTS?",
        "options": [
            "Slow convergence in very large games",
            "Cannot handle randomness",
            "Fails in deterministic games",
            "Requires depth limit"
        ],
        "correctAnswer": 0,
        "explanation": "MCTS can take many simulations to converge in huge search spaces."
    },
    {
        "id": 154,
        "topic": "Other Topics",
        "algorithm": "Game Search: Minimax",
        "difficulty": "Easy",
        "question": "Minimax is used in AI for which type of games?",
        "options": [
            "Two-player zero-sum games",
            "Single-player puzzles",
            "Multi-player games",
            "Random simulations"
        ],
        "correctAnswer": 0,
        "explanation": "Minimax is designed for competitive, two-player zero-sum games."
    },
    {
        "id": 155,
        "topic": "Other Topics",
        "algorithm": "Game Search: Alpha-Beta Pruning",
        "difficulty": "Easy",
        "question": "Alpha-Beta pruning reduces computation by:",
        "options": [
            "Eliminating unnecessary branches",
            "Adding more nodes",
            "Increasing depth",
            "Random moves"
        ],
        "correctAnswer": 0,
        "explanation": "Pruning avoids evaluating nodes that cannot affect the final decision."
    },
    {
        "id": 156,
        "topic": "Other Topics",
        "algorithm": "Game Search: Expectimax",
        "difficulty": "Medium",
        "question": "Which type of games requires Expectimax instead of Minimax?",
        "options": [
            "Games with randomness",
            "Deterministic board games",
            "Single-player puzzles",
            "Games with only one move"
        ],
        "correctAnswer": 0,
        "explanation": "Expectimax accounts for probabilistic outcomes, unlike deterministic Minimax."
    },

 
   
    {
        "id": 157,
        "topic": "Paradigms",
        "algorithm": "Backtracking",
        "difficulty": "Easy",
        "question": "Which of the following best describes backtracking?",
        "options": [
        "Trying all possible solutions without undoing choices",
        "Systematically exploring all solutions and undoing invalid ones",
        "Choosing the best solution at each step",
        "Dividing a problem into subproblems"
        ],
        "correctAnswer": 1,
        "explanation": "Backtracking systematically explores possible solutions and undoes choices when they lead to dead ends."
    },
    {
        "id": 158,
        "topic": "Paradigms",
        "algorithm": "Backtracking",
        "difficulty": "Easy",
        "question": "Which of these is a common application of backtracking?",
        "options": [
        "N-Queens Problem",
        "Binary Search",
        "Merge Sort",
        "Dijkstra's Algorithm"
        ],
        "correctAnswer": 0,
        "explanation": "The N-Queens problem is a classic backtracking example."
    },
    {
        "id": 159,
        "topic": "Paradigms",
        "algorithm": "Backtracking",
        "difficulty": "Medium",
        "question": "Which data structure is most closely associated with backtracking?",
        "options": [
        "Queue",
        "Stack",
        "Heap",
        "Graph"
        ],
        "correctAnswer": 1,
        "explanation": "Backtracking often uses the call stack or an explicit stack to manage choices."
    },
    {
        "id": 160,
        "topic": "Paradigms",
        "algorithm": "Backtracking",
        "difficulty": "Medium",
        "question": "When does backtracking stop exploring a path?",
        "options": [
        "When a partial solution is invalid",
        "When the algorithm has tried all possible options",
        "When it finds a greedy solution",
        "After a fixed number of iterations"
        ],
        "correctAnswer": 0,
        "explanation": "Backtracking stops exploring a path as soon as the partial solution becomes invalid."
    },
    {
        "id": 161,
        "topic": "Paradigms",
        "algorithm": "Backtracking",
        "difficulty": "Hard",
        "question": "What is the worst-case time complexity of backtracking algorithms like N-Queens?",
        "options": [
        "O(N^2)",
        "O(N!)",
        "O(log N)",
        "O(2^N)"
        ],
        "correctAnswer": 1,
        "explanation": "The N-Queens backtracking solution can explore O(N!) possibilities."
    },
    {
        "id": 162,
        "topic": "Paradigms",
        "algorithm": "Backtracking",
        "difficulty": "Hard",
        "question": "Which optimization helps improve the efficiency of backtracking?",
        "options": [
        "Memoization",
        "Pruning invalid paths early",
        "Random guessing",
        "Greedy selection"
        ],
        "correctAnswer": 1,
        "explanation": "Pruning reduces the number of paths explored by eliminating invalid ones early."
    },

    {
        "id": 163,
        "topic": "Paradigms",
        "algorithm": "Backtracking : N-Queens",
        "difficulty": "Easy",
        "question": "What is the objective of the N-Queens problem?",
        "options": [
        "Place queens randomly",
        "Place N queens so that no two attack each other",
        "Sort queens by size",
        "Maximize queen moves"
        ],
        "correctAnswer": 1,
        "explanation": "The goal is to place N queens on an N×N chessboard such that no two queens attack each other."
    },
    {
        "id": 164,
        "topic": "Paradigms",
        "algorithm": "Backtracking : N-Queens",
        "difficulty": "Easy",
        "question": "What is the board size in the 8-Queens problem?",
        "options": [
        "4x4",
        "6x6",
        "8x8",
        "10x10"
        ],
        "correctAnswer": 2,
        "explanation": "The 8-Queens problem uses an 8×8 chessboard."
    },
    {
        "id": 165,
        "topic": "Paradigms",
        "algorithm": "Backtracking : N-Queens",
        "difficulty": "Medium",
        "question": "Which algorithmic paradigm is most suitable for N-Queens?",
        "options": [
        "Greedy",
        "Dynamic Programming",
        "Backtracking",
        "Divide and Conquer"
        ],
        "correctAnswer": 2,
        "explanation": "Backtracking is the primary technique used to solve N-Queens."
    },
    {
        "id": 166,
        "topic": "Paradigms",
        "algorithm": "Backtracking : N-Queens",
        "difficulty": "Medium",
        "question": "What strategy is used to place queens in N-Queens with backtracking?",
        "options": [
        "Placing queens row by row",
        "Placing queens randomly",
        "Placing queens greedily",
        "Placing queens by sorting columns"
        ],
        "correctAnswer": 0,
        "explanation": "Backtracking places queens row by row and backtracks on conflicts."
    },
    {
        "id": 167,
        "topic": "Paradigms",
        "algorithm": "Backtracking : N-Queens",
        "difficulty": "Hard",
        "question": "How many distinct solutions exist for the 8-Queens problem?",
        "options": [
        "64",
        "92",
        "128",
        "256"
        ],
        "correctAnswer": 1,
        "explanation": "There are 92 distinct solutions for the 8-Queens problem."
    },
    {
        "id": 168,
        "topic": "Paradigms",
        "algorithm": "Backtracking : N-Queens",
        "difficulty": "Hard",
        "question": "What is the asymptotic time complexity of solving N-Queens using backtracking?",
        "options": [
        "O(N!)",
        "O(N^2)",
        "O(N log N)",
        "O(2^N)"
        ],
        "correctAnswer": 0,
        "explanation": "Backtracking for N-Queens has factorial time complexity O(N!)."
    },

    {
        "id": 169,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Sudoku",
        "difficulty": "Easy",
        "question": "What is the size of a standard Sudoku grid?",
        "options": [
        "6x6",
        "9x9",
        "12x12",
        "8x8"
        ],
        "correctAnswer": 1,
        "explanation": "Standard Sudoku puzzles are played on a 9x9 grid."
    },
    {
        "id": 170,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Sudoku",
        "difficulty": "Easy",
        "question": "How many sub-grids are there in a standard Sudoku puzzle?",
        "options": [
        "6",
        "9",
        "12",
        "16"
        ],
        "correctAnswer": 1,
        "explanation": "A 9x9 Sudoku grid is divided into 9 smaller 3x3 sub-grids."
    },
    {
        "id": 171,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Sudoku",
        "difficulty": "Medium",
        "question": "Which algorithm is most commonly used for solving Sudoku computationally?",
        "options": [
        "Greedy Algorithm",
        "Backtracking",
        "Divide and Conquer",
        "Dynamic Programming"
        ],
        "correctAnswer": 1,
        "explanation": "Backtracking is the most common method to solve Sudoku."
    },
    {
        "id": 172,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Sudoku",
        "difficulty": "Medium",
        "question": "What pruning strategy is used in Sudoku solving?",
        "options": [
        "Eliminating invalid digits early",
        "Skipping entire rows",
        "Randomly guessing values",
        "Sorting the digits"
        ],
        "correctAnswer": 0,
        "explanation": "Constraint checking removes invalid digits early to improve efficiency."
    },
    {
        "id": 173,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Sudoku",
        "difficulty": "Hard",
        "question": "What is the worst-case complexity of solving Sudoku with naive backtracking?",
        "options": [
        "O(1)",
        "O(9^n)",
        "O(n^2)",
        "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Naive Sudoku solving can explore up to O(9^n) possibilities."
    },
    {
        "id": 174,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Sudoku",
        "difficulty": "Hard",
        "question": "Which advanced human technique is difficult to implement programmatically?",
        "options": [
        "Naked pairs/triples",
        "Backtracking",
        "Binary Search",
        "Greedy heuristics"
        ],
        "correctAnswer": 0,
        "explanation": "Naked pairs/triples are advanced logical techniques used by humans in Sudoku solving."
    },
    {
        "id": 175,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Rat in a Maze",
        "difficulty": "Easy",
        "question": "What is the main objective in the Rat in a Maze problem?",
        "options": [
        "Find all possible paths in a maze",
        "Count the number of walls",
        "Escape the maze in minimum steps",
        "Place the rat randomly"
        ],
        "correctAnswer": 0,
        "explanation": "The goal is to find all paths from start to finish using backtracking."
    },
    {
        "id": 176,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Rat in a Maze",
        "difficulty": "Easy",
        "question": "Which of these structures represents the maze in this problem?",
        "options": [
        "Graph",
        "2D Matrix",
        "Linked List",
        "Stack"
        ],
        "correctAnswer": 1,
        "explanation": "A 2D matrix is commonly used to represent the maze with 0s and 1s."
    },
    {
        "id": 177,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Rat in a Maze",
        "difficulty": "Medium",
        "question": "Which algorithmic approach is used to explore paths in the maze?",
        "options": [
        "Greedy",
        "Backtracking",
        "Dynamic Programming",
        "Divide and Conquer"
        ],
        "correctAnswer": 1,
        "explanation": "Backtracking systematically explores all possible paths and backtracks on dead ends."
    },
    {
        "id": 178,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Rat in a Maze",
        "difficulty": "Medium",
        "question": "What condition is checked before moving the rat to the next cell?",
        "options": [
        "If the cell is within bounds and not blocked",
        "If the cell has already been visited",
        "If the cell contains a reward",
        "Both 1 and 2"
        ],
        "correctAnswer": 3,
        "explanation": "The rat moves only to valid, unvisited cells within the maze boundaries."
    },
    {
        "id": 179,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Rat in a Maze",
        "difficulty": "Hard",
        "question": "What is the time complexity of finding all paths in an N×N maze?",
        "options": [
        "O(N^2)",
        "O(2^(N^2))",
        "O(N!)",
        "O(N^N)"
        ],
        "correctAnswer": 1,
        "explanation": "The algorithm may explore all possible combinations of cells, giving O(2^(N^2)) complexity."
    },
    {
        "id": 180,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Rat in a Maze",
        "difficulty": "Hard",
        "question": "Which optimization can reduce the search space in Rat in a Maze?",
        "options": [
        "Pruning visited paths",
        "Random moves",
        "Greedy selection",
        "Sorting the cells"
        ],
        "correctAnswer": 0,
        "explanation": "Pruning prevents revisiting paths, reducing unnecessary computation."
    },

    {
        "id": 181,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Combination Sum",
        "difficulty": "Easy",
        "question": "What is the goal of the Combination Sum problem?",
        "options": [
        "Find a single combination of numbers",
        "Find all unique combinations that sum to target",
        "Sort numbers in ascending order",
        "Multiply numbers to reach target"
        ],
        "correctAnswer": 1,
        "explanation": "Combination Sum finds all combinations of numbers that add up to the target."
    },
    {
        "id": 182,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Combination Sum",
        "difficulty": "Easy",
        "question": "Which of these constraints is usually applied?",
        "options": [
        "Numbers can be used only once",
        "Numbers can be repeated",
        "Numbers must be negative",
        "Only prime numbers are allowed"
        ],
        "correctAnswer": 1,
        "explanation": "Numbers can typically be used multiple times to form combinations."
    },
    {
        "id": 183,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Combination Sum",
        "difficulty": "Medium",
        "question": "Which paradigm is commonly used to solve Combination Sum?",
        "options": [
        "Backtracking",
        "Greedy",
        "Dynamic Programming",
        "Divide and Conquer"
        ],
        "correctAnswer": 0,
        "explanation": "Backtracking explores all possible combinations and backtracks when necessary."
    },
    {
        "id": 184,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Combination Sum",
        "difficulty": "Medium",
        "question": "How do we avoid duplicate combinations?",
        "options": [
        "Sort the input and explore in order",
        "Use a hash set for duplicates",
        "Both 1 and 2",
        "Ignore duplicates"
        ],
        "correctAnswer": 2,
        "explanation": "Sorting and using a set ensures unique combinations only."
    },
    {
        "id": 185,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Combination Sum",
        "difficulty": "Hard",
        "question": "What is the worst-case complexity of Combination Sum backtracking solution?",
        "options": [
        "O(2^n)",
        "O(n^2)",
        "O(n!)",
        "O(n^n)"
        ],
        "correctAnswer": 0,
        "explanation": "The solution explores subsets of input, giving exponential time complexity O(2^n)."
    },
    {
        "id": 186,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Combination Sum",
        "difficulty": "Hard",
        "question": "Which technique can optimize repeated sum calculations?",
        "options": [
        "Memoization",
        "Greedy selection",
        "Random sampling",
        "Sorting"
        ],
        "correctAnswer": 0,
        "explanation": "Memoization stores previously computed sums to avoid redundant work."
    },

    {
        "id": 187,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Word Search",
        "difficulty": "Easy",
        "question": "What is the main goal of the Word Search problem?",
        "options": [
        "Find words in a grid of letters",
        "Count letters in a word",
        "Sort words alphabetically",
        "Replace letters randomly"
        ],
        "correctAnswer": 0,
        "explanation": "Word Search requires locating given words within a letter grid."
    },
    {
        "id": 188,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Word Search",
        "difficulty": "Easy",
        "question": "Which directions are typically considered when searching?",
        "options": [
        "Horizontally and vertically",
        "Diagonally",
        "All 8 directions",
        "Only horizontally"
        ],
        "correctAnswer": 2,
        "explanation": "All 8 directions (horizontal, vertical, diagonal) are used to locate words."
    },
    {
        "id": 189,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Word Search",
        "difficulty": "Medium",
        "question": "Which algorithmic technique is used for Word Search?",
        "options": [
        "Backtracking",
        "Dynamic Programming",
        "Greedy",
        "Divide and Conquer"
        ],
        "correctAnswer": 0,
        "explanation": "Backtracking is used to explore paths in the grid recursively."
    },
    {
        "id": 190,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Word Search",
        "difficulty": "Medium",
        "question": "How can we prevent revisiting the same cell in a word path?",
        "options": [
        "Mark cells as visited during recursion",
        "Use a global counter",
        "Ignore visited cells",
        "Sort the grid"
        ],
        "correctAnswer": 0,
        "explanation": "Marking visited cells prevents cycles and incorrect paths."
    },
    {
        "id": 191,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Word Search",
        "difficulty": "Hard",
        "question": "What is the worst-case time complexity for finding a word of length L in an N×N grid?",
        "options": [
        "O(L)",
        "O(N^2 * 4^L)",
        "O(N^L)",
        "O(N!)"
        ],
        "correctAnswer": 1,
        "explanation": "Each letter has up to 4 directions, giving O(N^2 * 4^L) in the worst case."
    },
    {
        "id": 192,
        "topic": "Paradigms",
        "algorithm": "Backtracking : Word Search",
        "difficulty": "Hard",
        "question": "Which optimization can reduce the search in Word Search?",
        "options": [
        "Trie for prefix checking",
        "Random cell selection",
        "Sorting words",
        "Greedy search"
        ],
        "correctAnswer": 0,
        "explanation": "Using a Trie allows early pruning if no word starts with the current prefix."
    },
    {
        "id": 193,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Fibonacci Sequence",
        "difficulty": "Easy",
        "question": "What is the 0th Fibonacci number?",
        "options": [
        "0",
        "1",
        "2",
        "Undefined"
        ],
        "correctAnswer": 0,
        "explanation": "The Fibonacci sequence starts with 0 as the 0th element."
    },
    {
        "id": 194,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Fibonacci Sequence",
        "difficulty": "Easy",
        "question": "Which recurrence relation defines Fibonacci numbers?",
        "options": [
        "F(n) = F(n-1) + F(n-2)",
        "F(n) = F(n-1) * F(n-2)",
        "F(n) = F(n-2) - F(n-1)",
        "F(n) = n^2"
        ],
        "correctAnswer": 0,
        "explanation": "Each Fibonacci number is the sum of the two preceding numbers."
    },
    {
        "id": 195,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Fibonacci Sequence",
        "difficulty": "Medium",
        "question": "Which approach avoids exponential recursion in Fibonacci calculation?",
        "options": [
        "Backtracking",
        "Memoization",
        "Greedy",
        "Sorting"
        ],
        "correctAnswer": 1,
        "explanation": "Memoization stores previously computed results to prevent repeated calculations."
    },
    {
        "id": 196,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Fibonacci Sequence",
        "difficulty": "Medium",
        "question": "What is the time complexity of Fibonacci with memoization?",
        "options": [
        "O(2^n)",
        "O(n)",
        "O(n^2)",
        "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Memoization reduces the time complexity to linear O(n)."
    },
    {
        "id": 197,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Fibonacci Sequence",
        "difficulty": "Hard",
        "question": "Which space optimization can be applied to Fibonacci DP?",
        "options": [
        "Using two variables instead of an array",
        "Using a stack",
        "Using recursion only",
        "Using sorting"
        ],
        "correctAnswer": 0,
        "explanation": "Only the last two numbers are needed, so we can use two variables to reduce space."
    },
    {
        "id": 198,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Fibonacci Sequence",
        "difficulty": "Hard",
        "question": "Which formula allows O(log n) Fibonacci computation?",
        "options": [
        "Binet's formula / Matrix exponentiation",
        "Greedy summation",
        "Backtracking",
        "Linear DP"
        ],
        "correctAnswer": 0,
        "explanation": "Matrix exponentiation or Binet's formula computes Fibonacci in logarithmic time."
    },

    {
        "id": 199,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : 0/1 Knapsack",
        "difficulty": "Easy",
        "question": "In 0/1 Knapsack, each item can be:",
        "options": [
        "Taken multiple times",
        "Taken once or not taken",
        "Taken partially",
        "Ignored completely"
        ],
        "correctAnswer": 1,
        "explanation": "Each item can either be included once or excluded."
    },
    {
        "id": 200,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : 0/1 Knapsack",
        "difficulty": "Easy",
        "question": "What is the main goal of 0/1 Knapsack?",
        "options": [
        "Maximize profit without exceeding weight",
        "Minimize weight",
        "Sort items by value",
        "Select items randomly"
        ],
        "correctAnswer": 0,
        "explanation": "We aim to maximize total value while staying within the weight limit."
    },
    {
        "id": 201,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : 0/1 Knapsack",
        "difficulty": "Medium",
        "question": "Which DP table size is commonly used for 0/1 Knapsack?",
        "options": [
        "n × W",
        "n × n",
        "W × W",
        "1D array only"
        ],
        "correctAnswer": 0,
        "explanation": "The DP table has dimensions [number of items] × [capacity W]."
    },
    {
        "id": 202,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : 0/1 Knapsack",
        "difficulty": "Medium",
        "question": "What recurrence relation is used in 0/1 Knapsack?",
        "options": [
        "dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])",
        "dp[i][w] = dp[i-1][w] + dp[i-1][w-weight[i]]",
        "dp[i][w] = min(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])",
        "dp[i][w] = dp[i-1][w] * value[i]"
        ],
        "correctAnswer": 0,
        "explanation": "The DP formula considers including or excluding the current item."
    },
    {
        "id": 203,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : 0/1 Knapsack",
        "difficulty": "Hard",
        "question": "What is the time complexity of standard DP 0/1 Knapsack?",
        "options": [
        "O(n*W)",
        "O(n^2)",
        "O(2^n)",
        "O(n*log W)"
        ],
        "correctAnswer": 0,
        "explanation": "Time complexity is O(n*W) where n = number of items and W = capacity."
    },
    {
        "id": 204,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : 0/1 Knapsack",
        "difficulty": "Hard",
        "question": "Which optimization reduces space to O(W) in 0/1 Knapsack?",
        "options": [
        "Using a 1D DP array and iterating weights in reverse",
        "Using recursion only",
        "Sorting items first",
        "Greedy selection"
        ],
        "correctAnswer": 0,
        "explanation": "1D DP array with reverse iteration reduces space while maintaining correctness."
    },

    {
        "id": 205,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Coin Change",
        "difficulty": "Easy",
        "question": "What is the Coin Change problem?",
        "options": [
        "Find the minimum number of coins to make a target",
        "Count total coins available",
        "Sort coins",
        "Maximize coin value"
        ],
        "correctAnswer": 0,
        "explanation": "We aim to make a target amount using the fewest coins."
    },
    {
        "id": 206,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Coin Change",
        "difficulty": "Easy",
        "question": "Which type of DP is used in Coin Change problem?",
        "options": [
        "Top-down with memoization",
        "Greedy only",
        "Divide and Conquer",
        "Backtracking only"
        ],
        "correctAnswer": 0,
        "explanation": "Top-down (or bottom-up) DP is used to avoid recomputation."
    },
    {
        "id": 207,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Coin Change",
        "difficulty": "Medium",
        "question": "Which DP table represents the minimum coins for each amount?",
        "options": [
        "dp[amount]",
        "dp[coins]",
        "dp[value]",
        "dp[weight]"
        ],
        "correctAnswer": 0,
        "explanation": "dp[i] stores the minimum coins needed to make amount i."
    },
    {
        "id": 208,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Coin Change",
        "difficulty": "Medium",
        "question": "How to handle amounts that cannot be formed?",
        "options": [
        "Initialize with INF or large value",
        "Use 0",
        "Skip them",
        "Use negative numbers"
        ],
        "correctAnswer": 0,
        "explanation": "Initialize DP with a large number to indicate unreachable amounts."
    },
    {
        "id": 209,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Coin Change",
        "difficulty": "Hard",
        "question": "What is the time complexity of DP Coin Change with n coins and amount A?",
        "options": [
        "O(n*A)",
        "O(A^n)",
        "O(n^2)",
        "O(n*log A)"
        ],
        "correctAnswer": 0,
        "explanation": "Each amount is computed by iterating over n coins, giving O(n*A)."
    },
    {
        "id": 210,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Coin Change",
        "difficulty": "Hard",
        "question": "Which optimization can reduce space in Coin Change DP?",
        "options": [
        "1D array storing min coins for each amount",
        "Sorting coins",
        "Greedy selection",
        "Recursive stack only"
        ],
        "correctAnswer": 0,
        "explanation": "Only 1D array of size amount+1 is needed, reducing space."
    },
    {
        "id": 211,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Longest Common Subsequence",
        "difficulty": "Easy",
        "question": "What does LCS stand for?",
        "options": [
        "Longest Continuous Subarray",
        "Longest Common Subsequence",
        "Largest Common Sum",
        "Least Common Subsequence"
        ],
        "correctAnswer": 1,
        "explanation": "LCS stands for Longest Common Subsequence."
    },
    {
        "id": 212,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Longest Common Subsequence",
        "difficulty": "Easy",
        "question": "Which of these pairs has an LCS of length 3?",
        "options": [
        "ABCD & ACBD",
        "ABC & DEF",
        "XYZ & XYZ",
        "AA & BB"
        ],
        "correctAnswer": 0,
        "explanation": "ABCD and ACBD share 'ABD' as a common subsequence of length 3."
    },
    {
        "id": 213,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Longest Common Subsequence",
        "difficulty": "Medium",
        "question": "Which recurrence defines LCS?",
        "options": [
        "If X[i] = Y[j], dp[i][j] = dp[i-1][j-1]+1 else max(dp[i-1][j], dp[i][j-1])",
        "dp[i][j] = dp[i-1][j] + dp[i][j-1]",
        "dp[i][j] = dp[i-1][j-1]",
        "dp[i][j] = max(dp[i][j-1], dp[i-1][j-1])"
        ],
        "correctAnswer": 0,
        "explanation": "The standard LCS recurrence considers match or max of previous subproblems."
    },
    {
        "id": 214,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Longest Common Subsequence",
        "difficulty": "Medium",
        "question": "Which DP table size is used for sequences of length m and n?",
        "options": [
        "m × n",
        "m + n",
        "2 × max(m,n)",
        "m^2"
        ],
        "correctAnswer": 0,
        "explanation": "The DP table has dimensions [m+1][n+1]."
    },
    {
        "id": 215,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Longest Common Subsequence",
        "difficulty": "Hard",
        "question": "What is the time complexity of LCS DP solution?",
        "options": [
        "O(m+n)",
        "O(m*n)",
        "O(2^n)",
        "O(n!)"
        ],
        "correctAnswer": 1,
        "explanation": "The standard DP solution computes each cell once, giving O(m*n)."
    },
    {
        "id": 216,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Longest Common Subsequence",
        "difficulty": "Hard",
        "question": "Which optimization reduces space to O(min(m,n))?",
        "options": [
        "Using only two rows of DP table",
        "Memoization with recursion",
        "Greedy LCS",
        "Sorting sequences"
        ],
        "correctAnswer": 0,
        "explanation": "Storing only previous and current row suffices for DP computation."
    },

    {
        "id": 217,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Matrix Chain Multiplication",
        "difficulty": "Easy",
        "question": "What is the goal in Matrix Chain Multiplication?",
        "options": [
        "Multiply matrices in any order",
        "Minimize total scalar multiplications",
        "Maximize determinant",
        "Sort matrices by size"
        ],
        "correctAnswer": 1,
        "explanation": "We seek the order that minimizes scalar multiplications."
    },
    {
        "id": 218,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Matrix Chain Multiplication",
        "difficulty": "Easy",
        "question": "Which operation counts in cost calculation?",
        "options": [
        "Matrix addition",
        "Scalar multiplications",
        "Matrix inversion",
        "Determinant"
        ],
        "correctAnswer": 1,
        "explanation": "The number of scalar multiplications determines the cost."
    },
    {
        "id": 219,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Matrix Chain Multiplication",
        "difficulty": "Medium",
        "question": "Which DP approach is used?",
        "options": [
        "Bottom-up",
        "Greedy",
        "Divide and Conquer without DP",
        "Backtracking"
        ],
        "correctAnswer": 0,
        "explanation": "Bottom-up DP computes minimum costs for increasing chain lengths."
    },
    {
        "id": 220,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Matrix Chain Multiplication",
        "difficulty": "Medium",
        "question": "What does dp[i][j] represent?",
        "options": [
        "Minimum cost to multiply matrices i to j",
        "Maximum cost",
        "Sum of matrix elements",
        "Matrix dimensions"
        ],
        "correctAnswer": 0,
        "explanation": "dp[i][j] stores the minimal scalar multiplication cost for matrices i..j."
    },
    {
        "id": 221,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Matrix Chain Multiplication",
        "difficulty": "Hard",
        "question": "Time complexity of standard DP solution?",
        "options": [
        "O(n^2)",
        "O(n^3)",
        "O(2^n)",
        "O(n!)"
        ],
        "correctAnswer": 1,
        "explanation": "Triple nested loops yield O(n^3) complexity."
    },
    {
        "id": 222,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Matrix Chain Multiplication",
        "difficulty": "Hard",
        "question": "Which optimization can reconstruct optimal multiplication order?",
        "options": [
        "Store split points in separate table",
        "Memoize recursively",
        "Sort matrices",
        "Greedy splitting"
        ],
        "correctAnswer": 0,
        "explanation": "A table of split indices allows reconstruction of the optimal order."
    },

    {
        "id": 223,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Minimum Path Sum",
        "difficulty": "Easy",
        "question": "What is the problem statement?",
        "options": [
        "Find path with minimum sum from top-left to bottom-right",
        "Maximize path sum",
        "Count number of paths",
        "Sort grid values"
        ],
        "correctAnswer": 0,
        "explanation": "The goal is to find a path with the smallest sum."
    },
    {
        "id": 224,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Minimum Path Sum",
        "difficulty": "Easy",
        "question": "Which moves are allowed?",
        "options": [
        "Down or Right",
        "Up or Left",
        "Diagonally only",
        "All 8 directions"
        ],
        "correctAnswer": 0,
        "explanation": "Only right and down moves are allowed in standard formulation."
    },
    {
        "id": 225,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Minimum Path Sum",
        "difficulty": "Medium",
        "question": "Which recurrence is used?",
        "options": [
        "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])",
        "dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])",
        "dp[i][j] = grid[i][j] * dp[i-1][j]",
        "dp[i][j] = dp[i-1][j-1]"
        ],
        "correctAnswer": 0,
        "explanation": "The minimum path sum is current cell plus min of top or left."
    },
    {
        "id": 226,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Minimum Path Sum",
        "difficulty": "Medium",
        "question": "Time complexity for an m×n grid?",
        "options": [
        "O(m*n)",
        "O(m+n)",
        "O(2^(m*n))",
        "O(m^2*n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Each cell is computed once, giving O(m*n)."
    },
    {
        "id": 227,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Minimum Path Sum",
        "difficulty": "Hard",
        "question": "Which space optimization is possible?",
        "options": [
        "Use a single row or column",
        "Use recursion only",
        "Store full DP table",
        "Sort the grid"
        ],
        "correctAnswer": 0,
        "explanation": "Only previous row or column is needed for DP computation."
    },
    {
        "id": 228,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Minimum Path Sum",
        "difficulty": "Hard",
        "question": "Which variant allows diagonal moves?",
        "options": [
        "Diagonal DP variant",
        "0/1 Knapsack",
        "Fibonacci",
        "LCS"
        ],
        "correctAnswer": 0,
        "explanation": "Allowing diagonal moves requires updating the DP formula to consider diagonal predecessor."
    },

    {
        "id": 229,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Subset Sum",
        "difficulty": "Easy",
        "question": "What is the problem statement?",
        "options": [
        "Check if a subset sums to target",
        "Find all subsets",
        "Sort numbers",
        "Find max element"
        ],
        "correctAnswer": 0,
        "explanation": "Subset Sum checks if any subset sums to a given target."
    },
    {
        "id": 230,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Subset Sum",
        "difficulty": "Easy",
        "question": "Which of these is a valid DP approach?",
        "options": [
        "dp[i][j] = dp[i-1][j] || dp[i-1][j-arr[i]]",
        "dp[i][j] = dp[i-1][j] + arr[i]",
        "dp[i][j] = dp[i][j-1]",
        "dp[i][j] = arr[i]*arr[j]"
        ],
        "correctAnswer": 0,
        "explanation": "DP tracks whether a sum j can be formed using first i elements."
    },
    {
        "id": 231,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Subset Sum",
        "difficulty": "Medium",
        "question": "Time complexity of standard DP Subset Sum?",
        "options": [
        "O(n*target)",
        "O(n^2)",
        "O(2^n)",
        "O(n!)"
        ],
        "correctAnswer": 0,
        "explanation": "We iterate over n elements and sums up to target."
    },
    {
        "id": 232,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Subset Sum",
        "difficulty": "Medium",
        "question": "Space optimization possible?",
        "options": [
        "Use 1D array of size target+1",
        "Use recursion only",
        "Sort elements",
        "Use 2D array always"
        ],
        "correctAnswer": 0,
        "explanation": "1D array suffices by updating from target downwards."
    },
    {
        "id": 233,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Subset Sum",
        "difficulty": "Hard",
        "question": "Subset Sum problem is a special case of which problem?",
        "options": [
        "0/1 Knapsack",
        "Coin Change",
        "Fibonacci",
        "LCS"
        ],
        "correctAnswer": 0,
        "explanation": "Subset Sum is a 0/1 Knapsack variant where item values = weights and capacity = target."
    },
    {
        "id": 234,
        "topic": "Paradigms",
        "algorithm": "Dynamic Programming : Subset Sum",
        "difficulty": "Hard",
        "question": "Which technique can solve large Subset Sum instances efficiently?",
        "options": [
        "Bitset DP or optimized space DP",
        "Greedy",
        "Sorting",
        "Backtracking only"
        ],
        "correctAnswer": 0,
        "explanation": "Bitset DP or optimized 1D DP allows handling large sums efficiently."
    },
    {
        "id": 235,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Activity Selection",
        "difficulty": "Easy",
        "question": "What is the main goal of the Activity Selection problem?",
        "options": [
        "Maximize number of non-overlapping activities",
        "Minimize activity duration",
        "Sort activities by name",
        "Maximize total duration"
        ],
        "correctAnswer": 0,
        "explanation": "The goal is to select the maximum number of activities that don't overlap."
    },
    {
        "id": 236,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Activity Selection",
        "difficulty": "Easy",
        "question": "Which greedy criterion is used?",
        "options": [
        "Earliest finish time first",
        "Longest duration first",
        "Random selection",
        "Latest start time first"
        ],
        "correctAnswer": 0,
        "explanation": "Choosing activities by earliest finish time ensures optimal selection."
    },
    {
        "id": 237,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Activity Selection",
        "difficulty": "Medium",
        "question": "Time complexity of standard greedy solution after sorting?",
        "options": [
        "O(n log n)",
        "O(n^2)",
        "O(n)",
        "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Sorting takes O(n log n), selection afterward is O(n)."
    },
    {
        "id": 238,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Activity Selection",
        "difficulty": "Medium",
        "question": "What data structure is commonly used for activity representation?",
        "options": [
        "Array or list of (start, end) times",
        "Graph adjacency matrix",
        "Stack",
        "Queue"
        ],
        "correctAnswer": 0,
        "explanation": "Each activity is represented by its start and finish time."
    },
    {
        "id": 239,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Activity Selection",
        "difficulty": "Hard",
        "question": "Which is true about greedy correctness?",
        "options": [
        "Earliest finish time greedy gives optimal solution",
        "Random selection gives optimal solution",
        "Longest duration gives optimal solution",
        "None of the above"
        ],
        "correctAnswer": 0,
        "explanation": "Earliest finish time is proven to produce the maximum number of activities."
    },
    {
        "id": 240,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Activity Selection",
        "difficulty": "Hard",
        "question": "Which proof technique shows correctness?",
        "options": [
        "Greedy stays ahead / exchange argument",
        "Dynamic programming",
        "Recursion",
        "Divide and Conquer"
        ],
        "correctAnswer": 0,
        "explanation": "Exchange argument demonstrates greedy choice leads to optimal solution."
    },

    {
        "id": 241,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Fractional Knapsack",
        "difficulty": "Easy",
        "question": "What is allowed in Fractional Knapsack?",
        "options": [
        "Take fractions of items",
        "Take each item only once",
        "Skip items completely",
        "Sort items by name"
        ],
        "correctAnswer": 0,
        "explanation": "Unlike 0/1 Knapsack, items can be taken partially."
    },
    {
        "id": 242,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Fractional Knapsack",
        "difficulty": "Easy",
        "question": "Which criterion is used to select items?",
        "options": [
        "Highest value/weight ratio first",
        "Lowest value first",
        "Random order",
        "Longest item first"
        ],
        "correctAnswer": 0,
        "explanation": "Greedy choice selects items with highest value-to-weight ratio."
    },
    {
        "id": 243,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Fractional Knapsack",
        "difficulty": "Medium",
        "question": "Time complexity after sorting n items?",
        "options": [
        "O(n log n)",
        "O(n^2)",
        "O(n)",
        "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Sorting dominates the algorithm; selection is linear."
    },
    {
        "id": 244,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Fractional Knapsack",
        "difficulty": "Medium",
        "question": "Which data structure is commonly used to sort items?",
        "options": [
        "Array or list",
        "Queue",
        "Graph",
        "Stack"
        ],
        "correctAnswer": 0,
        "explanation": "Items are sorted in an array/list by value/weight ratio."
    },
    {
        "id": 245,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Fractional Knapsack",
        "difficulty": "Hard",
        "question": "Why is greedy optimal for Fractional Knapsack?",
        "options": [
        "Fractional property allows linear combination of best ratios",
        "Because recursion works",
        "Sorting guarantees minimal weight",
        "Random choice works"
        ],
        "correctAnswer": 0,
        "explanation": "Fractions allow us to always take as much as possible from the best ratio item."
    },
    {
        "id": 246,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Fractional Knapsack",
        "difficulty": "Hard",
        "question": "Time complexity if items are unsorted?",
        "options": [
        "O(n log n)",
        "O(n^2)",
        "O(n)",
        "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Sorting is necessary before linear selection; otherwise, cannot guarantee optimality."
    },

    {
        "id": 247,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Huffman Encoding",
        "difficulty": "Easy",
        "question": "What is Huffman Encoding used for?",
        "options": [
        "Data compression",
        "Sorting numbers",
        "Finding shortest paths",
        "Graph traversal"
        ],
        "correctAnswer": 0,
        "explanation": "Huffman encoding compresses data by using variable-length codes."
    },
    {
        "id": 248,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Huffman Encoding",
        "difficulty": "Easy",
        "question": "Which data structure is used?",
        "options": [
        "Min-heap or priority queue",
        "Stack",
        "Queue",
        "Array only"
        ],
        "correctAnswer": 0,
        "explanation": "A min-heap efficiently extracts the two lowest frequency nodes repeatedly."
    },
    {
        "id": 249,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Huffman Encoding",
        "difficulty": "Medium",
        "question": "Greedy choice in Huffman?",
        "options": [
        "Combine two nodes with smallest frequencies",
        "Choose largest node",
        "Random nodes",
        "Sort characters alphabetically"
        ],
        "correctAnswer": 0,
        "explanation": "Always combine two smallest frequencies to form a new node."
    },
    {
        "id": 250,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Huffman Encoding",
        "difficulty": "Medium",
        "question": "Time complexity for n characters?",
        "options": [
        "O(n log n)",
        "O(n^2)",
        "O(n)",
        "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Building min-heap takes O(n log n) and each merge is logarithmic."
    },
    {
        "id": 251,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Huffman Encoding",
        "difficulty": "Hard",
        "question": "Why is greedy optimal for Huffman?",
        "options": [
        "Optimal prefix property ensures minimal encoding length",
        "Because recursion works",
        "Sorting guarantees minimal weight",
        "Random choice works"
        ],
        "correctAnswer": 0,
        "explanation": "Greedy choice ensures the resulting prefix code has minimal total weighted path length."
    },
    {
        "id": 252,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Huffman Encoding",
        "difficulty": "Hard",
        "question": "Which proof method shows optimality?",
        "options": [
        "Greedy stays ahead / exchange argument",
        "Dynamic programming",
        "Recursion only",
        "Divide and Conquer"
        ],
        "correctAnswer": 0,
        "explanation": "Exchange argument proves combining smallest frequencies is optimal."
    },
    {
        "id": 253,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Job Scheduling",
        "difficulty": "Easy",
        "question": "What is the goal in the Job Scheduling problem?",
        "options": [
        "Maximize profit by scheduling non-overlapping jobs",
        "Minimize job durations",
        "Sort jobs by name",
        "Maximize number of jobs"
        ],
        "correctAnswer": 0,
        "explanation": "The goal is to select jobs to maximize total profit without conflicts."
    },
    {
        "id": 254,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Job Scheduling",
        "difficulty": "Easy",
        "question": "Which criterion is commonly used to schedule jobs?",
        "options": [
        "Earliest deadline first",
        "Longest processing time first",
        "Random selection",
        "Alphabetical order"
        ],
        "correctAnswer": 0,
        "explanation": "Earliest deadline first ensures feasible scheduling and often optimal profit."
    },
    {
        "id": 255,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Job Scheduling",
        "difficulty": "Medium",
        "question": "Time complexity after sorting n jobs by deadline?",
        "options": [
        "O(n log n)",
        "O(n^2)",
        "O(n)",
        "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Sorting dominates; selection afterward is linear."
    },
    {
        "id": 256,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Job Scheduling",
        "difficulty": "Medium",
        "question": "Which data structure can help track free time slots efficiently?",
        "options": [
        "Disjoint set / Union-Find",
        "Stack",
        "Queue",
        "Array only"
        ],
        "correctAnswer": 0,
        "explanation": "Union-Find helps efficiently find the latest available slot."
    },
    {
        "id": 257,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Job Scheduling",
        "difficulty": "Hard",
        "question": "Greedy optimality proof often uses which technique?",
        "options": [
        "Exchange argument",
        "Dynamic programming",
        "Recursion only",
        "Divide and Conquer"
        ],
        "correctAnswer": 0,
        "explanation": "Exchange argument shows that swapping jobs maintains optimal profit."
    },
    {
        "id": 258,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Job Scheduling",
        "difficulty": "Hard",
        "question": "Which variant allows fractional scheduling?",
        "options": [
        "Job Fractional Scheduling (like Fractional Knapsack)",
        "0/1 Job Scheduling",
        "Random scheduling",
        "None"
        ],
        "correctAnswer": 0,
        "explanation": "Fractional scheduling allows splitting jobs partially to maximize profit."
    },

    {
        "id": 259,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Minimum Spanning Tree",
        "difficulty": "Easy",
        "question": "What is the goal of MST?",
        "options": [
        "Connect all vertices with minimum total edge weight",
        "Maximize total edge weight",
        "Count number of edges",
        "Sort vertices"
        ],
        "correctAnswer": 0,
        "explanation": "MST connects all vertices using the minimum total edge weight."
    },
    {
        "id": 260,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Minimum Spanning Tree",
        "difficulty": "Easy",
        "question": "Which algorithms are greedy for MST?",
        "options": [
        "Prim and Kruskal",
        "Dijkstra and BFS",
        "DFS and Bellman-Ford",
        "Floyd-Warshall"
        ],
        "correctAnswer": 0,
        "explanation": "Prim and Kruskal build MSTs greedily by choosing minimum edges."
    },
    {
        "id": 261,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Minimum Spanning Tree",
        "difficulty": "Medium",
        "question": "Kruskal’s algorithm requires which data structure?",
        "options": [
        "Disjoint set / Union-Find",
        "Queue",
        "Stack",
        "Heap only"
        ],
        "correctAnswer": 0,
        "explanation": "Union-Find detects cycles efficiently when adding edges."
    },
    {
        "id": 262,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Minimum Spanning Tree",
        "difficulty": "Medium",
        "question": "Prim’s algorithm can be implemented efficiently using which structure?",
        "options": [
        "Min-heap / Priority queue",
        "Stack",
        "Disjoint set",
        "Array only"
        ],
        "correctAnswer": 0,
        "explanation": "Priority queue efficiently picks the next minimum edge connecting the MST."
    },
    {
        "id": 263,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Minimum Spanning Tree",
        "difficulty": "Hard",
        "question": "Time complexity of Kruskal’s algorithm with n vertices and m edges?",
        "options": [
        "O(m log m + m α(n))",
        "O(n^2)",
        "O(n log n)",
        "O(m^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Sorting edges is O(m log m) and Union-Find operations are near constant (α(n))."
    },
    {
        "id": 264,
        "topic": "Paradigms",
        "algorithm": "Greedy Algorithms : Minimum Spanning Tree",
        "difficulty": "Hard",
        "question": "Time complexity of Prim’s algorithm using min-heap?",
        "options": [
        "O((V+E) log V)",
        "O(V^2)",
        "O(E^2)",
        "O(V log V)"
        ],
        "correctAnswer": 0,
        "explanation": "Each edge may trigger a heap update, giving O((V+E) log V) complexity."
    },
    {
        "id": 265,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Merge Sort",
        "difficulty": "Easy",
        "question": "Which paradigm does Merge Sort use?",
        "options": [
        "Divide and Conquer",
        "Greedy",
        "Dynamic Programming",
        "Backtracking"
        ],
        "correctAnswer": 0,
        "explanation": "Merge Sort divides the array, sorts recursively, and merges — classic divide and conquer."
    },
    {
        "id": 266,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Merge Sort",
        "difficulty": "Easy",
        "question": "What is the time complexity of Merge Sort in the worst case?",
        "options": [
        "O(n log n)",
        "O(n^2)",
        "O(log n)",
        "O(n)"
        ],
        "correctAnswer": 0,
        "explanation": "Merge Sort always divides and merges, giving O(n log n) complexity."
    },
    {
        "id": 267,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Merge Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly used during merging?",
        "options": [
        "Temporary array",
        "Stack",
        "Queue",
        "Linked list only"
        ],
        "correctAnswer": 0,
        "explanation": "A temporary array stores merged elements before copying back."
    },
    {
        "id": 268,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Merge Sort",
        "difficulty": "Medium",
        "question": "Space complexity of Merge Sort?",
        "options": [
        "O(n)",
        "O(1)",
        "O(log n)",
        "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Merge Sort requires O(n) extra space for the temporary array."
    },
    {
        "id": 269,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Merge Sort",
        "difficulty": "Hard",
        "question": "Which technique can reduce Merge Sort’s space usage?",
        "options": [
        "In-place merging",
        "Greedy selection",
        "Recursion only",
        "Backtracking"
        ],
        "correctAnswer": 0,
        "explanation": "In-place merging techniques reduce additional memory, though more complex."
    },
    {
        "id": 270,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Merge Sort",
        "difficulty": "Hard",
        "question": "Merge Sort is stable. What does stability mean?",
        "options": [
        "Equal elements retain relative order",
        "Always fastest sorting",
        "Requires extra memory",
        "Divides array recursively"
        ],
        "correctAnswer": 0,
        "explanation": "Stability preserves the order of equal elements after sorting."
    },

    {
        "id": 271,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Quick Sort",
        "difficulty": "Easy",
        "question": "Which paradigm does Quick Sort use?",
        "options": [
        "Divide and Conquer",
        "Greedy",
        "Dynamic Programming",
        "Backtracking"
        ],
        "correctAnswer": 0,
        "explanation": "Quick Sort divides the array around a pivot and conquers recursively."
    },
    {
        "id": 272,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Quick Sort",
        "difficulty": "Easy",
        "question": "Worst-case time complexity of Quick Sort?",
        "options": [
        "O(n^2)",
        "O(n log n)",
        "O(log n)",
        "O(n)"
        ],
        "correctAnswer": 0,
        "explanation": "If pivot selection is poor (sorted array), Quick Sort degrades to O(n^2)."
    },
    {
        "id": 273,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Quick Sort",
        "difficulty": "Medium",
        "question": "Which pivot selection technique is commonly used?",
        "options": [
        "Randomized or median-of-three",
        "First element always",
        "Last element only",
        "Middle element only"
        ],
        "correctAnswer": 0,
        "explanation": "Random or median-of-three pivot improves average performance and reduces worst-case likelihood."
    },
    {
        "id": 274,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Quick Sort",
        "difficulty": "Medium",
        "question": "Average-case time complexity?",
        "options": [
        "O(n log n)",
        "O(n^2)",
        "O(log n)",
        "O(n)"
        ],
        "correctAnswer": 0,
        "explanation": "With balanced partitioning, Quick Sort runs in O(n log n) on average."
    },
    {
        "id": 275,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Quick Sort",
        "difficulty": "Hard",
        "question": "Is Quick Sort stable?",
        "options": [
        "No",
        "Yes",
        "Only for small arrays",
        "Depends on pivot"
        ],
        "correctAnswer": 0,
        "explanation": "Standard Quick Sort is not stable; equal elements may change relative order."
    },
    {
        "id": 276,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Quick Sort",
        "difficulty": "Hard",
        "question": "Space complexity of Quick Sort (recursive)?",
        "options": [
        "O(log n) average",
        "O(n)",
        "O(n log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "Recursive calls use O(log n) stack space on average."
    },

    {
        "id": 277,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Binary Search",
        "difficulty": "Easy",
        "question": "Binary Search works on which type of array?",
        "options": [
        "Sorted array",
        "Unsorted array",
        "Random array",
        "Linked list only"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Search requires a sorted array to divide search space efficiently."
    },
    {
        "id": 278,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Binary Search",
        "difficulty": "Easy",
        "question": "Time complexity of Binary Search?",
        "options": [
        "O(log n)",
        "O(n)",
        "O(n log n)",
        "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Each step halves the search space, giving O(log n)."
    },
    {
        "id": 279,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Binary Search",
        "difficulty": "Medium",
        "question": "Which implementation is more space-efficient?",
        "options": [
        "Iterative",
        "Recursive",
        "Both same",
        "Depends on array"
        ],
        "correctAnswer": 0,
        "explanation": "Iterative Binary Search uses O(1) space; recursion uses O(log n) stack."
    },
    {
        "id": 280,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Binary Search",
        "difficulty": "Medium",
        "question": "Binary Search can be adapted for which type of problem?",
        "options": [
        "Finding first/last occurrence",
        "Sorting array",
        "Linear search",
        "Counting elements"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Search can locate first/last occurrence in sorted arrays."
    },
    {
        "id": 281,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Binary Search",
        "difficulty": "Hard",
        "question": "Which variant works on rotated sorted arrays?",
        "options": [
        "Modified Binary Search",
        "Standard Binary Search",
        "Linear search",
        "Quick Search"
        ],
        "correctAnswer": 0,
        "explanation": "Modified Binary Search accounts for rotation to find target correctly."
    },
    {
        "id": 282,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Binary Search",
        "difficulty": "Hard",
        "question": "Binary Search in infinite or unknown size array?",
        "options": [
        "Exponential search followed by Binary Search",
        "Linear search",
        "Quick Search",
        "Merge Search"
        ],
        "correctAnswer": 0,
        "explanation": "Exponential search finds a range, then binary search locates the element."
    },

    {
        "id": 283,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Maximum Subarray Sum",
        "difficulty": "Easy",
        "question": "What is the goal of Maximum Subarray Sum problem?",
        "options": [
        "Find contiguous subarray with maximum sum",
        "Sort array",
        "Find largest element",
        "Count subarrays"
        ],
        "correctAnswer": 0,
        "explanation": "We seek a contiguous subarray whose sum is maximum."
    },
    {
        "id": 284,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Maximum Subarray Sum",
        "difficulty": "Easy",
        "question": "Which simple algorithm can solve it in O(n^2)?",
        "options": [
        "Check all subarrays",
        "Binary search",
        "Greedy selection",
        "Merge sort"
        ],
        "correctAnswer": 0,
        "explanation": "Brute-force checks sums of all possible contiguous subarrays."
    },
    {
        "id": 285,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Maximum Subarray Sum",
        "difficulty": "Medium",
        "question": "Optimal O(n) algorithm is called?",
        "options": [
        "Kadane’s algorithm",
        "Merge Sum",
        "Divide Sum",
        "Quick Sum"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s algorithm computes max sum in linear time using DP-like approach."
    },
    {
        "id": 286,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Maximum Subarray Sum",
        "difficulty": "Medium",
        "question": "Kadane’s algorithm keeps track of?",
        "options": [
        "Current max ending here and overall max",
        "All subarrays",
        "Sum of first half",
        "Count of positive numbers"
        ],
        "correctAnswer": 0,
        "explanation": "It maintains current subarray sum and updates overall maximum."
    },
    {
        "id": 287,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Maximum Subarray Sum",
        "difficulty": "Hard",
        "question": "Time complexity of Kadane’s algorithm?",
        "options": [
        "O(n)",
        "O(n log n)",
        "O(n^2)",
        "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Each element is processed once, giving linear O(n) complexity."
    },
    {
        "id": 288,
        "topic": "Paradigms",
        "algorithm": "Divide & Conquer : Maximum Subarray Sum",
        "difficulty": "Hard",
        "question": "Can Kadane’s algorithm handle all-negative arrays?",
        "options": [
        "Yes, by tracking maximum element",
        "No",
        "Only positive arrays",
        "Depends on size"
        ],
        "correctAnswer": 0,
        "explanation": "It works for all-negative arrays by choosing the maximum single element."
    },
    {
        "id": 289,
        "topic": "Other Topics",
        "algorithm": "trees: Preorder Traversal",
        "difficulty": "Easy",
        "question": "What is the order of nodes in Preorder Traversal?",
        "options": [
        "Root, Left, Right",
        "Left, Root, Right",
        "Left, Right, Root",
        "Right, Root, Left"
        ],
        "correctAnswer": 0,
        "explanation": "Preorder traversal visits the root first, then the left subtree, then the right subtree."
    },
    {
        "id": 290,
        "topic": "Other Topics",
        "algorithm": "trees: Preorder Traversal",
        "difficulty": "Easy",
        "question": "Preorder traversal is typically implemented using?",
        "options": [
        "Recursion or stack",
        "Queue only",
        "Heap",
        "Graph"
        ],
        "correctAnswer": 0,
        "explanation": "Recursion or an explicit stack is used to simulate recursive calls."
    },
    {
        "id": 291,
        "topic": "Other Topics",
        "algorithm": "trees: Preorder Traversal",
        "difficulty": "Medium",
        "question": "Time complexity of Preorder Traversal?",
        "options": [
        "O(n)",
        "O(n log n)",
        "O(log n)",
        "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Each node is visited once, giving O(n) time complexity."
    },
    {
        "id": 292,
        "topic": "Other Topics",
        "algorithm": "trees: Preorder Traversal",
        "difficulty": "Medium",
        "question": "Which data structure can be used for iterative preorder traversal?",
        "options": [
        "Stack",
        "Queue",
        "Heap",
        "Linked list"
        ],
        "correctAnswer": 0,
        "explanation": "A stack simulates the recursive calls for preorder traversal."
    },
    {
        "id": 293,
        "topic": "Other Topics",
        "algorithm": "trees: Preorder Traversal",
        "difficulty": "Hard",
        "question": "Preorder traversal is used to?",
        "options": [
        "Serialize a tree",
        "Sort elements",
        "Search efficiently",
        "Delete nodes"
        ],
        "correctAnswer": 0,
        "explanation": "Preorder is often used for tree serialization and reconstruction."
    },
    {
        "id": 294,
        "topic": "Other Topics",
        "algorithm": "trees: Preorder Traversal",
        "difficulty": "Hard",
        "question": "Space complexity of recursive Preorder Traversal?",
        "options": [
        "O(h) where h is tree height",
        "O(n)",
        "O(log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "Recursive calls stack can go up to the height of the tree."
    },

    {
        "id": 295,
        "topic": "Other Topics",
        "algorithm": "trees: Inorder Traversal",
        "difficulty": "Easy",
        "question": "Order of nodes in Inorder Traversal?",
        "options": [
        "Left, Root, Right",
        "Root, Left, Right",
        "Right, Root, Left",
        "Left, Right, Root"
        ],
        "correctAnswer": 0,
        "explanation": "Inorder visits left subtree, then root, then right subtree."
    },
    {
        "id": 296,
        "topic": "Other Topics",
        "algorithm": "trees: Inorder Traversal",
        "difficulty": "Easy",
        "question": "Inorder traversal of a BST gives?",
        "options": [
        "Sorted sequence",
        "Reverse sorted sequence",
        "Random order",
        "Heap order"
        ],
        "correctAnswer": 0,
        "explanation": "Inorder traversal of a BST visits nodes in ascending order."
    },
    {
        "id": 297,
        "topic": "Other Topics",
        "algorithm": "trees: Inorder Traversal",
        "difficulty": "Medium",
        "question": "Iterative Inorder traversal uses?",
        "options": [
        "Stack",
        "Queue",
        "Heap",
        "Graph"
        ],
        "correctAnswer": 0,
        "explanation": "A stack is used to track nodes while visiting leftmost nodes first."
    },
    {
        "id": 298,
        "topic": "Other Topics",
        "algorithm": "trees: Inorder Traversal",
        "difficulty": "Medium",
        "question": "Time complexity of Inorder Traversal?",
        "options": [
        "O(n)",
        "O(n log n)",
        "O(log n)",
        "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Each node is visited exactly once, O(n)."
    },
    {
        "id": 299,
        "topic": "Other Topics",
        "algorithm": "trees: Inorder Traversal",
        "difficulty": "Hard",
        "question": "Morris Traversal for Inorder achieves?",
        "options": [
        "O(1) space",
        "O(n log n) time",
        "Stack-based simulation",
        "Heap-based storage"
        ],
        "correctAnswer": 0,
        "explanation": "Morris Traversal uses threaded binary tree concept to traverse in O(1) space."
    },
    {
        "id": 300,
        "topic": "Other Topics",
        "algorithm": "trees: Inorder Traversal",
        "difficulty": "Hard",
        "question": "Inorder is useful to?",
        "options": [
        "Validate BST property",
        "Compute height",
        "Delete node",
        "Traverse level-wise"
        ],
        "correctAnswer": 0,
        "explanation": "Inorder traversal of a BST should produce a sorted sequence; this validates BST."
    },
    {
        "id": 301,
        "topic": "Other Topics",
        "algorithm": "trees: Postorder Traversal",
        "difficulty": "Easy",
        "question": "Order of nodes in Postorder Traversal?",
        "options": [
        "Left, Right, Root",
        "Root, Left, Right",
        "Left, Root, Right",
        "Right, Root, Left"
        ],
        "correctAnswer": 0,
        "explanation": "Postorder visits left subtree, then right subtree, then root."
    },
    {
        "id": 302,
        "topic": "Other Topics",
        "algorithm": "trees: Postorder Traversal",
        "difficulty": "Easy",
        "question": "Postorder traversal is useful for?",
        "options": [
        "Deleting a tree",
        "Printing nodes",
        "Searching elements",
        "Balancing tree"
        ],
        "correctAnswer": 0,
        "explanation": "Postorder is used to delete a tree safely by visiting children first."
    },
    {
        "id": 303,
        "topic": "Other Topics",
        "algorithm": "trees: Postorder Traversal",
        "difficulty": "Medium",
        "question": "Iterative Postorder traversal can use?",
        "options": [
        "Two stacks",
        "Queue",
        "Heap",
        "Graph"
        ],
        "correctAnswer": 0,
        "explanation": "Two stacks can simulate postorder traversal iteratively."
    },
    {
        "id": 304,
        "topic": "Other Topics",
        "algorithm": "trees: Postorder Traversal",
        "difficulty": "Medium",
        "question": "Time complexity of Postorder Traversal?",
        "options": [
        "O(n)",
        "O(n log n)",
        "O(log n)",
        "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Each node is visited once."
    },
    {
        "id": 305,
        "topic": "Other Topics",
        "algorithm": "trees: Postorder Traversal",
        "difficulty": "Hard",
        "question": "Space complexity of recursive Postorder?",
        "options": [
        "O(h) where h is tree height",
        "O(n)",
        "O(log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "Recursive calls stack can go up to tree height."
    },
    {
        "id": 306,
        "topic": "Other Topics",
        "algorithm": "trees: Postorder Traversal",
        "difficulty": "Hard",
        "question": "Postorder can be used to compute?",
        "options": [
        "Subtree sizes or expression evaluation",
        "Node heights only",
        "Inorder sequence",
        "Level order sequence"
        ],
        "correctAnswer": 0,
        "explanation": "Postorder allows processing children before root, useful in evaluation and subtree computations."
    },

    {
        "id": 307,
        "topic": "Other Topics",
        "algorithm": "trees: Level Order Traversal",
        "difficulty": "Easy",
        "question": "Level Order Traversal visits nodes in?",
        "options": [
        "Breadth-first manner",
        "Depth-first manner",
        "Random order",
        "Reverse order"
        ],
        "correctAnswer": 0,
        "explanation": "Level order uses BFS to visit nodes level by level."
    },
    {
        "id": 308,
        "topic": "Other Topics",
        "algorithm": "trees: Level Order Traversal",
        "difficulty": "Easy",
        "question": "Which data structure is used for Level Order Traversal?",
        "options": [
        "Queue",
        "Stack",
        "Heap",
        "Graph"
        ],
        "correctAnswer": 0,
        "explanation": "Queue stores nodes of each level to process in FIFO order."
    },
    {
        "id": 309,
        "topic": "Other Topics",
        "algorithm": "trees: Level Order Traversal",
        "difficulty": "Medium",
        "question": "Time complexity of Level Order Traversal?",
        "options": [
        "O(n)",
        "O(n log n)",
        "O(log n)",
        "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Each node is visited once."
    },
    {
        "id": 310,
        "topic": "Other Topics",
        "algorithm": "trees: Level Order Traversal",
        "difficulty": "Medium",
        "question": "Level order can also be called?",
        "options": [
        "Breadth-First Traversal",
        "Depth-First Traversal",
        "Preorder Traversal",
        "Inorder Traversal"
        ],
        "correctAnswer": 0,
        "explanation": "Level order is equivalent to BFS."
    },
    {
        "id": 311,
        "topic": "Other Topics",
        "algorithm": "trees: Level Order Traversal",
        "difficulty": "Hard",
        "question": "Space complexity of level order traversal?",
        "options": [
        "O(width of tree)",
        "O(h)",
        "O(n log n)",
        "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Queue stores up to the maximum number of nodes at any level."
    },
    {
        "id": 312,
        "topic": "Other Topics",
        "algorithm": "trees: Level Order Traversal",
        "difficulty": "Hard",
        "question": "Level order can be used to compute?",
        "options": [
        "Height of tree, level sums, zigzag traversal",
        "Only leaf nodes",
        "Inorder sequence",
        "Preorder sequence"
        ],
        "correctAnswer": 0,
        "explanation": "It allows computations involving levels like height, sum, or zigzag ordering."
    },

    {
        "id": 313,
        "topic": "Other Topics",
        "algorithm": "trees: BST Insert",
        "difficulty": "Easy",
        "question": "In BST, where is a new node inserted?",
        "options": [
        "Maintaining BST property",
        "At root always",
        "Leftmost position",
        "Rightmost position"
        ],
        "correctAnswer": 0,
        "explanation": "BST insertion ensures left < root < right property."
    },
    {
        "id": 314,
        "topic": "Other Topics",
        "algorithm": "trees: BST Insert",
        "difficulty": "Easy",
        "question": "Time complexity of BST insertion (balanced tree)?",
        "options": [
        "O(log n)",
        "O(n)",
        "O(n log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "Balanced BST has height log n, giving O(log n) insertion time."
    },
    {
        "id": 315,
        "topic": "Other Topics",
        "algorithm": "trees: BST Insert",
        "difficulty": "Medium",
        "question": "Insertion in BST may cause?",
        "options": [
        "Tree imbalance (for unbalanced BST)",
        "Tree deletion",
        "Traversal change",
        "Sorting error"
        ],
        "correctAnswer": 0,
        "explanation": "Unbalanced insertions may skew the tree."
    },
    {
        "id": 316,
        "topic": "Other Topics",
        "algorithm": "trees: BST Insert",
        "difficulty": "Medium",
        "question": "BST insertion can be implemented using?",
        "options": [
        "Recursion or iteration",
        "Queue only",
        "Heap only",
        "Graph traversal"
        ],
        "correctAnswer": 0,
        "explanation": "Both recursive and iterative methods are used for BST insertion."
    },
    {
        "id": 317,
        "topic": "Other Topics",
        "algorithm": "trees: BST Insert",
        "difficulty": "Hard",
        "question": "Time complexity of BST insertion in worst-case (skewed tree)?",
        "options": [
        "O(n)",
        "O(log n)",
        "O(n log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "A skewed BST has height n, giving O(n) insertion time."
    },
    {
        "id": 318,
        "topic": "Other Topics",
        "algorithm": "trees: BST Insert",
        "difficulty": "Hard",
        "question": "BST insertion maintains?",
        "options": [
        "BST property",
        "Heap property",
        "Graph adjacency",
        "Traversal order"
        ],
        "correctAnswer": 0,
        "explanation": "Insertion ensures BST left < root < right property."
    },
    {
        "id": 319,
        "topic": "Other Topics",
        "algorithm": "trees: BST Search",
        "difficulty": "Easy",
        "question": "In a BST, how do you search for a value?",
        "options": [
        "Compare with root and traverse left or right",
        "Check all nodes sequentially",
        "Use a hash table",
        "Random traversal"
        ],
        "correctAnswer": 0,
        "explanation": "BST search compares the target with root and moves left or right recursively or iteratively."
    },
    {
        "id": 320,
        "topic": "Other Topics",
        "algorithm": "trees: BST Search",
        "difficulty": "Easy",
        "question": "Time complexity of BST search in a balanced tree?",
        "options": [
        "O(log n)",
        "O(n)",
        "O(n log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "Balanced BST has height log n, so search takes O(log n)."
    },
    {
        "id": 321,
        "topic": "Other Topics",
        "algorithm": "trees: BST Search",
        "difficulty": "Medium",
        "question": "Time complexity of BST search in worst-case (skewed tree)?",
        "options": [
        "O(n)",
        "O(log n)",
        "O(n log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "A skewed BST has height n, so search can take O(n) in worst case."
    },
    {
        "id": 322,
        "topic": "Other Topics",
        "algorithm": "trees: BST Search",
        "difficulty": "Medium",
        "question": "BST search can be implemented using?",
        "options": [
        "Recursion or iteration",
        "Queue only",
        "Heap only",
        "Stack only"
        ],
        "correctAnswer": 0,
        "explanation": "Both recursive and iterative approaches are commonly used."
    },
    {
        "id": 323,
        "topic": "Other Topics",
        "algorithm": "trees: BST Search",
        "difficulty": "Hard",
        "question": "Searching a non-existent element in BST returns?",
        "options": [
        "Null or None",
        "Root node",
        "Random node",
        "All nodes"
        ],
        "correctAnswer": 0,
        "explanation": "If the element is not found, search returns null (or None in Python)."
    },
    {
        "id": 324,
        "topic": "Other Topics",
        "algorithm": "trees: BST Search",
        "difficulty": "Hard",
        "question": "BST search efficiency depends on?",
        "options": [
        "Tree height",
        "Node values",
        "Queue usage",
        "Traversal type"
        ],
        "correctAnswer": 0,
        "explanation": "Search efficiency is determined by tree height; balanced trees give O(log n)."
    },

    {
        "id": 325,
        "topic": "Other Topics",
        "algorithm": "trees: BST Delete",
        "difficulty": "Easy",
        "question": "Deleting a node with no children in BST?",
        "options": [
        "Simply remove the node",
        "Replace with root",
        "Move left subtree",
        "Move right subtree"
        ],
        "correctAnswer": 0,
        "explanation": "A leaf node can be removed directly without affecting BST property."
    },
    {
        "id": 326,
        "topic": "Other Topics",
        "algorithm": "trees: BST Delete",
        "difficulty": "Easy",
        "question": "Deleting a node with one child?",
        "options": [
        "Replace node with its child",
        "Replace with root",
        "Remove both subtrees",
        "Do nothing"
        ],
        "correctAnswer": 0,
        "explanation": "The node is replaced by its only child to maintain BST property."
    },
    {
        "id": 327,
        "topic": "Other Topics",
        "algorithm": "trees: BST Delete",
        "difficulty": "Medium",
        "question": "Deleting a node with two children?",
        "options": [
        "Replace with inorder successor or predecessor",
        "Remove both subtrees",
        "Replace with root",
        "Random node"
        ],
        "correctAnswer": 0,
        "explanation": "Replace the node with its inorder successor (or predecessor) and delete that successor."
    },
    {
        "id": 328,
        "topic": "Other Topics",
        "algorithm": "trees: BST Delete",
        "difficulty": "Medium",
        "question": "Time complexity of BST delete (balanced tree)?",
        "options": [
        "O(log n)",
        "O(n)",
        "O(n log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "Delete involves search plus adjustment, giving O(log n) in balanced BST."
    },
    {
        "id": 329,
        "topic": "Other Topics",
        "algorithm": "trees: BST Delete",
        "difficulty": "Hard",
        "question": "Time complexity of BST delete (skewed tree)?",
        "options": [
        "O(n)",
        "O(log n)",
        "O(n log n)",
        "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "Skewed BST has height n, so delete can take O(n)."
    },
    {
        "id": 330,
        "topic": "Other Topics",
        "algorithm": "trees: BST Delete",
        "difficulty": "Hard",
        "question": "BST delete maintains?",
        "options": [
        "BST property",
        "Heap property",
        "Queue order",
        "Traversal order"
        ],
        "correctAnswer": 0,
        "explanation": "Deletion preserves the BST left < root < right property."
    },
    {
        "id": 331,
        "topic": "Other Topics",
    "algorithm": "Branch & Bound",
    "difficulty": "Easy",
    "question": "Which of the following is a key advantage of Branch & Bound over brute force?",
    "options": [
        "It guarantees sorting in linear time",
        "It reduces the number of candidate solutions to examine",
        "It always finds the exact solution without computation",
        "It converts problems into trees automatically"
    ],
    "correctAnswer": 1,
    "explanation": "Branch & Bound prunes branches that cannot lead to optimal solutions, reducing the search space compared to brute force."
},
    {
        "id": 332,
         "topic": "Other Topics",
    "algorithm": "Branch & Bound",
    "difficulty": "Easy",
    "question": "In Branch & Bound, what is the purpose of a 'bound' function?",
    "options": [
        "To count the total number of nodes in the tree",
        "To estimate the best possible solution in a subtree",
        "To sort candidate solutions by size",
        "To generate random solutions quickly"
    ],
    "correctAnswer": 1,
    "explanation": "The bound function provides an estimate of the best achievable solution in a subtree, allowing the algorithm to prune unpromising branches."
},
    {
        "id": 333,
        "topic": "Other Topics",
    "algorithm": "Branch & Bound",
    "difficulty": "Easy",
    "question": "Which problem-solving approach is Branch & Bound most similar to?",
    "options": [
        "Greedy algorithm",
        "Backtracking",
        "Dynamic programming",
        "Divide and conquer"
    ],
    "correctAnswer": 1,
    "explanation": "Branch & Bound explores solution space systematically like backtracking, but uses bounds to prune suboptimal branches."
},
    {
        "id": 334,
        "topic": "Other Topics",
    "algorithm": "Game Search",
    "difficulty": "Medium",
    "question": "In game tree search, what is the main purpose of a heuristic evaluation function?",
    "options": [
        "To estimate the value of non-terminal positions",
        "To find the exact optimal move",
        "To count the number of possible moves",
        "To generate random moves"
    ],
    "correctAnswer": 0,
    "explanation": "Heuristic evaluation functions estimate the desirability of non-terminal positions when the full search to terminal nodes is impractical."
},
    {
        "id": 335,
        "topic": "Other Topics",
    "algorithm": "Game Search",
    "difficulty": "Hard",
    "question": "In Monte Carlo Tree Search (MCTS), what is the primary challenge when the branching factor is extremely high?",
    "options": [
        "Balancing exploration and exploitation efficiently",
        "Evaluating terminal nodes directly",
        "Sorting the moves alphabetically",
        "Avoiding hash collisions"
    ],
    "correctAnswer": 0,
    "explanation": "When the branching factor is very high, MCTS must carefully balance exploration of new nodes and exploitation of promising moves to ensure meaningful search within limited simulations."
},
    {
        "id": 336,
         "topic": "Other Topics",
    "algorithm": "Game Search",
    "difficulty": "Hard",
    "question": "In adversarial games with imperfect information, which strategy helps handle uncertainty in game search algorithms?",
    "options": [
        "Using Expectimax with chance nodes",
        "Applying standard Minimax only",
        "Ignoring opponent moves",
        "Using hash tables for memoization"
    ],
    "correctAnswer": 0,
    "explanation": "Expectimax incorporates chance nodes to account for uncertainty and probabilistic outcomes, making it suitable for games with imperfect information."
},
    {
        "id": 337,
        "topic": "Other Topics",
        "algorithm": "Huffman Coding",
        "difficulty": "Easy",
        "question": "Huffman coding is mainly used for?",
        "options": [
            "Data compression",
            "Sorting arrays",
            "Graph traversal",
            "Pattern matching"
        ],
        "correctAnswer": 0,
        "explanation": "Huffman coding compresses data by assigning shorter codes to frequent characters."
    },
    {
        "id": 338,
        "topic": "Other Topics",
        "algorithm": "Huffman Coding",
        "difficulty": "Easy",
        "question": "What kind of tree does Huffman coding use?",
        "options": [
            "Binary Tree",
            "AVL Tree",
            "Trie",
            "B-Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Huffman coding constructs a binary tree where leaves represent characters."
    },
    {
        "id": 339,
        "topic": "Other Topics",
        "algorithm": "Huffman Coding",
        "difficulty": "Medium",
        "question": "Which nodes are combined first in Huffman coding?",
        "options": [
            "Two lowest-frequency nodes",
            "Two highest-frequency nodes",
            "Random nodes",
            "Middle-frequency nodes"
        ],
        "correctAnswer": 0,
        "explanation": "The two smallest frequency nodes are merged to form a new node repeatedly."
    },
    {
        "id": 340,
        "topic": "Other Topics",
        "algorithm": "Huffman Coding",
        "difficulty": "Medium",
        "question": "The time complexity of building a Huffman Tree is?",
        "options": [
            "O(n log n)",
            "O(n²)",
            "O(log n)",
            "O(n)"
        ],
        "correctAnswer": 0,
        "explanation": "Building the Huffman Tree involves sorting or using a min-heap, giving O(n log n)."
    },
    {
        "id": 341,
        "topic": "Other Topics",
        "algorithm": "Huffman Coding",
        "difficulty": "Hard",
        "question": "Huffman coding is optimal when:",
        "options": [
            "Symbol probabilities are known and independent",
            "Data is random",
            "Symbols repeat uniformly",
            "Compression ratio is fixed"
        ],
        "correctAnswer": 0,
        "explanation": "It gives the best compression when symbol frequencies are known and independent."
    },
    {
        "id": 342,
        "topic": "Other Topics",
        "algorithm": "Huffman Coding",
        "difficulty": "Hard",
        "question": "Which limitation does Huffman coding have?",
        "options": [
            "Does not handle variable-length sequences efficiently",
            "Cannot adapt to changing frequencies",
            "Cannot represent binary data",
            "Always increases data size"
        ],
        "correctAnswer": 1,
        "explanation": "Huffman coding is static; adaptive Huffman handles changing frequencies better."
    },
    {
        "id": 343,
        "topic": "Other Topics",
        "algorithm": "KMP Algorithm",
        "difficulty": "Easy",
        "question": "What problem does the KMP algorithm solve?",
        "options": [
            "Pattern matching in strings",
            "Shortest path finding",
            "Data compression",
            "Sorting characters"
        ],
        "correctAnswer": 0,
        "explanation": "KMP is used for pattern searching within a text efficiently."
    },
    {
        "id": 344,
        "topic": "Other Topics",
        "algorithm": "KMP Algorithm",
        "difficulty": "Easy",
        "question": "What is the main advantage of KMP over the naive approach?",
        "options": [
            "It avoids re-checking characters",
            "It uses less memory",
            "It sorts strings faster",
            "It compresses data"
        ],
        "correctAnswer": 0,
        "explanation": "KMP avoids redundant comparisons by precomputing information in the LPS array."
    },
    {
        "id": 345,
        "topic": "Other Topics",
        "algorithm": "KMP Algorithm",
        "difficulty": "Medium",
        "question": "What does the LPS array represent in KMP?",
        "options": [
            "Longest proper prefix which is also a suffix",
            "Least possible substring",
            "Length of processed string",
            "Lexicographically smallest prefix"
        ],
        "correctAnswer": 0,
        "explanation": "The LPS array stores the length of the longest proper prefix that is also a suffix."
    },
    {
        "id": 346,
        "topic": "Other Topics",
        "algorithm": "KMP Algorithm",
        "difficulty": "Medium",
        "question": "Time complexity of KMP pattern matching is?",
        "options": [
            "O(n + m)",
            "O(n * m)",
            "O(log n)",
            "O(n²)"
        ],
        "correctAnswer": 0,
        "explanation": "KMP processes both text and pattern once, leading to O(n + m) complexity."
    },
    {
        "id": 347,
        "topic": "Other Topics",
        "algorithm": "KMP Algorithm",
        "difficulty": "Hard",
        "question": "In KMP, when a mismatch occurs, what determines the next shift of the pattern?",
        "options": [
            "The LPS array value of the previous index",
            "The position of mismatch",
            "Random offset",
            "Character ASCII difference"
        ],
        "correctAnswer": 0,
        "explanation": "The LPS array tells where to resume matching without re-checking characters."
    },
    {
        "id": 348,
        "topic": "Other Topics",
        "algorithm": "KMP Algorithm",
        "difficulty": "Hard",
        "question": "What is a key limitation of KMP in practical applications?",
        "options": [
            "High preprocessing time for short patterns",
            "Cannot handle binary data",
            "Requires sorted text",
            "Fails on repeating characters"
        ],
        "correctAnswer": 0,
        "explanation": "KMP’s preprocessing (LPS table) can be unnecessary overhead for small or one-time searches."
    },
    {
        "id": 349,
        "topic": "Other Topics",
    "algorithm": "Hashing",
    "difficulty": "Easy",
    "question": "What is the primary purpose of a hash function in a hash table?",
    "options": [
        "To map keys to specific indices in the table",
        "To sort data in ascending order",
        "To compress data efficiently",
        "To encrypt data for security"
    ],
    "correctAnswer": 0,
    "explanation": "A hash function maps keys to specific indices in a hash table, allowing for efficient data retrieval and storage."
},
    {
        "id": 350,
         "topic": "Other Topics",
    "algorithm": "Branch and Bound",
    "difficulty": "Easy",
    "question": "What is the main idea behind the Branch and Bound technique?",
    "options": [
        "Dividing the problem into smaller subproblems and pruning unpromising ones",
        "Randomly selecting a branch to explore first",
        "Storing all possible solutions before choosing the best one",
        "Sorting data before solving the problem"
    ],
    "correctAnswer": 0,
    "explanation": "Branch and Bound systematically divides a problem into subproblems (branching) and eliminates those that cannot yield better solutions (bounding), reducing computation time."
},
    {
        "topic": "Other Topics",
    "algorithm": "Branch and Bound",
    "difficulty": "Easy",
    "question": "In the Branch and Bound algorithm, what does the upper bound function represent?",
    "options": [
        "An estimate of the best possible solution from a node",
        "The number of nodes explored so far",
        "The smallest value of the objective function found",
        "The total number of branches in the tree"
    ],
    "correctAnswer": 0,
    "explanation": "The upper bound function provides an estimate of the best possible (maximum or minimum) value that can be obtained from a given node, helping to prune less promising branches."
},
    {
        "id": 352,
        "topic": "Other Topics",
    "algorithm": "Upper Bound Function",
    "difficulty": "Medium",
    "question": "Given a sorted array `arr = [2, 4, 4, 4, 6, 8]`, what is the index returned by the upper_bound function for the value `4`?",
    "options": [
        "1",
        "3",
        "4",
        "5"
    ],
    "correctAnswer": 2,
    "explanation": "The upper_bound function returns the index of the first element greater than the given value. Here, the first element greater than 4 is 6 at index 4."
},
    {
        "id": 353,
         "topic": "Other Topics",
    "algorithm": "Lower Bound Function",
    "difficulty": "Hard",
    "question": "Let `arr` be a sorted array. The lower_bound function returns the smallest index `i` such that `arr[i] >= x`. Which of the following mathematical conditions correctly represents this?",
    "options": [
        "arr[i] > x and arr[i-1] <= x",
        "arr[i] >= x and arr[i-1] < x",
        "arr[i] >= x and arr[i+1] > x",
        "arr[i] > x and arr[i+1] >= x"
    ],
    "correctAnswer": 1,
    "explanation": "Lower bound finds the first position where the element is greater than or equal to `x`. The element just before it must be less than `x`."
},
    {
        "id": 354,
         "algorithm": "Asymptotic Notations",
    "difficulty": "Hard",
    "question": "Suppose a function `f(n) = 3n^2 + 5n log n + 20`. Which of the following statements is correct regarding its asymptotic bounds?",
    "options": [
        "f(n) = O(n^2), f(n) = Ω(n^2), f(n) = Θ(n^2)",
        "f(n) = O(n^3), f(n) = Ω(n^2), f(n) = Θ(n^2)",
        "f(n) = O(n^2 log n), f(n) = Ω(n^2), f(n) = Θ(n^2 log n)",
        "f(n) = O(n^2), f(n) = Ω(n log n), f(n) = Θ(n^2 log n)"
    ],
    "correctAnswer": 0,
    "explanation": "The dominant term is 3n^2. Therefore, f(n) grows as n^2 asymptotically, making O(n^2), Ω(n^2), and Θ(n^2) all correct. Lower order terms like 5n log n do not affect the Θ notation."
},
    {
        "id": 355,
        "topic": "Data Structures",
        "algorithm": "Stack Visualization",
        "difficulty": "Easy",
        "question": "Which operation adds an element to the top of a stack?",
        "options": [
            "Push",
            "Pop",
            "Peek",
            "Insert"
        ],
        "correctAnswer": 0,
        "explanation": "Push adds an element to the top of the stack."
    },
    {
        "id": 356,
        "topic": "Data Structures",
        "algorithm": "Stack Visualization",
        "difficulty": "Easy",
        "question": "Which operation removes the top element from a stack?",
        "options": [
            "Pop",
            "Push",
            "Peek",
            "Delete"
        ],
        "correctAnswer": 0,
        "explanation": "Pop removes the top element from the stack."
    },
    {
        "id": 357,
        "topic": "Data Structures",
        "algorithm": "Stack Visualization",
        "difficulty": "Medium",
        "question": "What does the Peek operation do on a stack?",
        "options": [
            "Returns the top element without removing it",
            "Removes the top element",
            "Adds an element at the bottom",
            "Checks if the stack is empty"
        ],
        "correctAnswer": 0,
        "explanation": "Peek lets you see the top element without modifying the stack."
    },
    {
        "id": 358,
        "topic": "Data Structures",
        "algorithm": "Stack Visualization",
        "difficulty": "Medium",
        "question": "Time complexity of push and pop in a stack is?",
        "options": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Both push and pop are constant-time operations."
    },
    {
        "id": 359,
        "topic": "Data Structures",
        "algorithm": "Stack Visualization",
        "difficulty": "Hard",
        "question": "Which scenario illustrates a stack overflow?",
        "options": [
            "Trying to push onto a full stack",
            "Trying to pop from an empty stack",
            "Viewing the top element",
            "Traversing the stack"
        ],
        "correctAnswer": 0,
        "explanation": "Stack overflow happens when you try to push beyond its capacity."
    },
    {
        "id": 360,
        "topic": "Data Structures",
        "algorithm": "Stack Visualization",
        "difficulty": "Hard",
        "question": "Which stack implementation supports dynamic memory usage efficiently?",
        "options": [
            "Linked list",
            "Fixed-size array",
            "Queue",
            "Binary tree"
        ],
        "correctAnswer": 0,
        "explanation": "Linked lists allow dynamic growth without a fixed size."
    },
    {
        "id": 361,
        "topic": "Other Topics",
        "algorithm": "Cycle Detection",
        "difficulty": "Easy",
        "question": "What is a cycle in a graph?",
        "options": [
            "A path that starts and ends at the same vertex",
            "A path visiting all vertices once",
            "A path with no repeated edges",
            "A disconnected component"
        ],
        "correctAnswer": 0,
        "explanation": "A cycle is a path where the first and last vertices are the same."
    },
    {
        "id": 362,
        "topic": "Other Topics",
        "algorithm": "Cycle Detection",
        "difficulty": "Easy",
        "question": "Which data structure is commonly used to detect cycles in a graph?",
        "options": [
            "Visited set / recursion stack",
            "Queue",
            "Heap",
            "Trie"
        ],
        "correctAnswer": 0,
        "explanation": "DFS with a visited set or recursion stack is typically used to detect cycles."
    },
    {
        "id": 363,
        "topic": "Other Topics",
        "algorithm": "Cycle Detection",
        "difficulty": "Medium",
        "question": "Time complexity of cycle detection using DFS is?",
        "options": [
            "O(V + E)",
            "O(V²)",
            "O(E²)",
            "O(log V)"
        ],
        "correctAnswer": 0,
        "explanation": "DFS visits each vertex and edge once, giving O(V + E) time."
    },
    {
        "id": 364,
        "topic": "Other Topics",
        "algorithm": "Cycle Detection",
        "difficulty": "Medium",
        "question": "In a directed graph, a cycle is detected if a node is visited that is:",
        "options": [
            "Already in the recursion stack",
            "Already in the visited set only",
            "Disconnected from start",
            "Leaf node"
        ],
        "correctAnswer": 0,
        "explanation": "A back edge to a node in the recursion stack indicates a cycle in a directed graph."
    },
    {
        "id": 365,
        "topic": "Other Topics",
        "algorithm": "Cycle Detection",
        "difficulty": "Hard",
        "question": "Which algorithm can detect cycles in a directed graph using topological sorting?",
        "options": [
            "Kahn's Algorithm",
            "Dijkstra's Algorithm",
            "Prim's Algorithm",
            "Bellman-Ford Algorithm"
        ],
        "correctAnswer": 0,
        "explanation": "Kahn’s algorithm detects cycles by checking if topological sorting is possible."
    },
    {
        "id": 366,
        "topic": "Other Topics",
        "algorithm": "Cycle Detection",
        "difficulty": "Hard",
        "question": "Union-Find (Disjoint Set) can be used to detect cycles in which type of graph?",
        "options": [
            "Undirected graph",
            "Directed graph",
            "Weighted graph only",
            "Tree only"
        ],
        "correctAnswer": 0,
        "explanation": "Union-Find efficiently detects cycles in undirected graphs by checking if two vertices belong to the same set."
    } ,
    {
        "id": 367,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Easy",
        "question": "What problem does Kadane’s Algorithm solve?",
        "options": [
            "Finding maximum sum subarray",
            "Finding minimum spanning tree",
            "Detecting cycles in a graph",
            "Sorting an array"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s Algorithm finds the maximum sum of a contiguous subarray."
    },
    {
        "id": 368,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Easy",
        "question": "What is the time complexity of Kadane’s Algorithm?",
        "options": [
            "O(n)",
            "O(n²)",
            "O(log n)",
            "O(n log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s Algorithm runs in linear time O(n)."
    },
    {
        "id": 369,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Easy",
        "question": "What type of graph problem does Prim’s Algorithm solve?",
        "options": [
            "Minimum Spanning Tree",
            "Shortest Path",
            "Cycle Detection",
            "Maximum Flow"
        ],
        "correctAnswer": 0,
        "explanation": "Prim’s Algorithm is used to find a minimum spanning tree."
    },
    {
        "id": 370,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Easy",
        "question": "Prim’s Algorithm starts from:",
        "options": [
            "Any arbitrary vertex",
            "The vertex with the smallest degree",
            "The vertex with the largest degree",
            "The first vertex in the input"
        ],
        "correctAnswer": 0,
        "explanation": "Prim’s Algorithm can start from any vertex in the graph."
    },
    {
        "id": 371,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Easy",
        "question": "What data structure is commonly used by Kruskal’s Algorithm to detect cycles?",
        "options": [
            "Disjoint Set (Union-Find)",
            "Stack",
            "Queue",
            "Priority Queue"
        ],
        "correctAnswer": 0,
        "explanation": "Disjoint Set (Union-Find) is used to detect cycles in Kruskal’s Algorithm."
    },
    {
        "id": 372,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Easy",
        "question": "Which of the following best describes Kruskal’s Algorithm?",
        "options": [
            "Adds edges in increasing order of weight",
            "Adds vertices in decreasing order of degree",
            "Performs DFS to find cycles",
            "Uses dynamic programming"
        ],
        "correctAnswer": 0,
        "explanation": "Kruskal’s Algorithm adds edges in non-decreasing order of weight."
    },
    {
        "id": 373,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Easy",
        "question": "Which of these arrays would Kadane’s Algorithm process correctly?",
        "options": [
            "Array with both positive and negative numbers",
            "Only positive numbers",
            "Only negative numbers",
            "Only zeros"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s Algorithm works on arrays containing positive and negative numbers."
    },
    {
        "id": 374,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Easy",
        "question": "Prim’s Algorithm can be implemented efficiently using:",
        "options": [
            "Priority Queue",
            "Stack",
            "Queue",
            "Linked List"
        ],
        "correctAnswer": 0,
        "explanation": "Priority Queue helps efficiently pick the next minimum edge in Prim’s Algorithm."
    },
    {
        "id": 375,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Easy",
        "question": "Kruskal’s Algorithm requires the edges to be:",
        "options": [
            "Sorted by weight",
            "Sorted by vertex number",
            "Unsorted",
            "Sorted by color"
        ],
        "correctAnswer": 0,
        "explanation": "Edges are sorted by weight before processing in Kruskal’s Algorithm."
    },
    {
        "id": 376,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Easy",
        "question": "Kadane’s Algorithm is an example of:",
        "options": [
            "Dynamic Programming",
            "Greedy Algorithm",
            "Divide and Conquer",
            "Backtracking"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s Algorithm is a classic dynamic programming approach."
    },
    {
        "id": 377,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Medium",
        "question": "How does Kadane’s Algorithm handle negative sums when calculating maximum subarray?",
        "options": [
            "Resets current sum to zero when it becomes negative",
            "Ignores negative numbers",
            "Always adds negative numbers",
            "Stops immediately"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s resets the current sum when it drops below zero to maximize the sum."
    },
    {
        "id": 378,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Medium",
        "question": "What is the space complexity of Kadane’s Algorithm?",
        "options": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n²)"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s Algorithm uses constant extra space."
    },
    {
        "id": 379,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Medium",
        "question": "What data structure is typically used to implement Prim’s Algorithm efficiently?",
        "options": [
            "Min-Heap (Priority Queue)",
            "Stack",
            "Queue",
            "Array"
        ],
        "correctAnswer": 0,
        "explanation": "Min-Heap is used to efficiently pick the minimum weight edge."
    },
    {
        "id": 380,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Medium",
        "question": "Prim’s Algorithm is guaranteed to work only on:",
        "options": [
            "Connected graphs",
            "Disconnected graphs",
            "Directed graphs",
            "Weighted graphs without cycles"
        ],
        "correctAnswer": 0,
        "explanation": "Prim’s Algorithm requires the graph to be connected."
    },
    {
        "id": 381,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Medium",
        "question": "What is the overall time complexity of Kruskal’s Algorithm using a good Union-Find structure?",
        "options": [
            "O(E log E)",
            "O(V²)",
            "O(E²)",
            "O(V + E)"
        ],
        "correctAnswer": 0,
        "explanation": "Sorting edges dominates time complexity, O(E log E)."
    },
    {
        "id": 382,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Medium",
        "question": "When does Kruskal’s Algorithm reject an edge while building MST?",
        "options": [
            "If adding the edge creates a cycle",
            "If the edge is the heaviest",
            "If the edge connects two disconnected components",
            "If the edge is not adjacent to the current tree"
        ],
        "correctAnswer": 0,
        "explanation": "Edges creating cycles are rejected to keep MST acyclic."
    },
    {
        "id": 383,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Medium",
        "question": "If all numbers in the array are negative, Kadane’s Algorithm should return:",
        "options": [
            "The maximum (least negative) element",
            "Zero",
            "Sum of all elements",
            "Minimum element"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s returns the maximum single element if all are negative."
    },
    {
        "id": 384,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Medium",
        "question": "What happens if Prim’s Algorithm is applied to a disconnected graph?",
        "options": [
            "It finds MST for one connected component only",
            "It finds MST for the entire graph",
            "It fails with an error",
            "It converts graph to connected"
        ],
        "correctAnswer": 0,
        "explanation": "Prim’s only builds MST for the connected part it starts from."
    },
    {
        "id": 385,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Medium",
        "question": "Which of the following edge selections is valid in Kruskal’s Algorithm?",
        "options": [
            "Edges that connect two different components",
            "Edges that form cycles",
            "Edges with maximum weight first",
            "Edges with the same vertices as previously selected edges"
        ],
        "correctAnswer": 0,
        "explanation": "Kruskal’s selects edges that connect different components to avoid cycles."
    },
    {
        "id": 386,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Medium",
        "question": "Which technique does Kadane’s Algorithm primarily use to solve the problem?",
        "options": [
            "Dynamic programming",
            "Greedy approach",
            "Divide and conquer",
            "Backtracking"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s Algorithm is based on dynamic programming principles."
    },
    {
        "id": 387,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Hard",
        "question": "How can Kadane’s Algorithm be modified to find the maximum product subarray instead of sum?",
        "options": [
            "Keep track of both maximum and minimum products at each step",
            "Use the sum instead of product",
            "Ignore negative numbers",
            "Sort the array before applying"
        ],
        "correctAnswer": 0,
        "explanation": "Tracking both max and min products handles negative values affecting the product."
    },
    {
        "id": 388,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Hard",
        "question": "What is a key limitation of Kadane’s Algorithm when applied directly to 2D arrays?",
        "options": [
            "It only works for 1D arrays",
            "It cannot handle negative numbers",
            "It requires sorted arrays",
            "It only works for positive numbers"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s is for 1D arrays; 2D maximum subarray requires extensions like fixing left and right boundaries."
    },
    {
        "id": 389,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Hard",
        "question": "What is the worst-case time complexity of Prim’s Algorithm implemented with an adjacency matrix?",
        "options": [
            "O(V²)",
            "O(E log V)",
            "O(V + E)",
            "O(V log V)"
        ],
        "correctAnswer": 0,
        "explanation": "Using adjacency matrix results in O(V²) time complexity."
    },
    {
        "id": 390,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Hard",
        "question": "How does the choice of data structure impact Prim’s Algorithm’s performance on sparse graphs?",
        "options": [
            "Min-heap reduces time complexity significantly",
            "Linked list improves performance",
            "Stack reduces complexity",
            "Queue is the best choice"
        ],
        "correctAnswer": 0,
        "explanation": "Using a min-heap with adjacency lists optimizes Prim’s to O(E log V) on sparse graphs."
    },
    {
        "id": 391,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Hard",
        "question": "In Kruskal’s Algorithm, what optimization improves the efficiency of the Union-Find data structure?",
        "options": [
            "Union by rank and path compression",
            "Stack implementation",
            "Breadth-first search",
            "Sorting edges twice"
        ],
        "correctAnswer": 0,
        "explanation": "Union by rank and path compression optimize Union-Find operations to near O(1)."
    },
    {
        "id": 392,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Hard",
        "question": "How does Kruskal’s Algorithm behave with graphs having multiple edges of the same weight?",
        "options": [
            "It can choose any edge among equals, resulting in multiple MSTs",
            "It always chooses the first edge",
            "It fails to find MST",
            "It sorts edges by vertex number"
        ],
        "correctAnswer": 0,
        "explanation": "Multiple MSTs can exist when edges have the same weight; Kruskal’s may produce any valid MST."
    },
    {
        "id": 393,
        "topic": "Other Topics",
        "algorithm": "Kadane’s Algorithm",
        "difficulty": "Hard",
        "question": "Can Kadane’s Algorithm be adapted to find the maximum sum of non-contiguous subarray? If yes, how?",
        "options": [
            "No, Kadane’s is for contiguous subarrays only",
            "Yes, by modifying the algorithm to skip some elements",
            "Yes, by sorting the array first",
            "No, it works only on sorted arrays"
        ],
        "correctAnswer": 0,
        "explanation": "Kadane’s Algorithm specifically solves the maximum sum contiguous subarray problem; non-contiguous requires different approach."
    },
    {
        "id": 394,
        "topic": "Other Topics",
        "algorithm": "Prim’s Algorithm",
        "difficulty": "Hard",
        "question": "How is Prim’s Algorithm modified to work on disconnected graphs?",
        "options": [
            "Run Prim’s on each connected component separately",
            "Add edges to connect components arbitrarily",
            "Ignore disconnected parts",
            "Use DFS before Prim’s"
        ],
        "correctAnswer": 0,
        "explanation": "To handle disconnected graphs, run Prim’s MST algorithm on each connected component."
    },
    {
        "id": 395,
        "topic": "Other Topics",
        "algorithm": "Kruskal’s Algorithm",
        "difficulty": "Hard",
        "question": "What is the impact on Kruskal’s Algorithm if the input graph is already a tree?",
        "options": [
            "The algorithm immediately returns the tree as MST",
            "It will add extra edges",
            "It will fail to complete",
            "It needs re-sorting edges"
        ],
        "correctAnswer": 0,
        "explanation": "If input is already a tree (no cycles, V-1 edges), Kruskal’s simply returns it as MST."
    },
    {
    "id": 396,
    "topic": "Other Topics",
    "algorithm": "Prim’s Algorithm",
    "difficulty": "Hard",
    "question": "In Prim’s Algorithm, if two edges have the same minimum weight during selection, what could be the possible consequence in a graph with multiple equal-weight edges?",
    "options": [
        "It may produce different but valid MSTs depending on the chosen edge",
        "The algorithm will enter an infinite loop",
        "The resulting MST will always be the same regardless of edge selection",
        "The algorithm will fail to find any MST"
    ],
    "correctAnswer": 0,
    "explanation": "When multiple edges have equal weights, Prim’s Algorithm may choose any of them, potentially resulting in different but equally valid minimum spanning trees since MSTs are not necessarily unique in such graphs."
}

,
    {
        "id": 397,
        "topic": "Graph",
        "algorithm": "BFS",
        "difficulty": "Easy",
        "question": "What does BFS stand for in graph algorithms?",
        "options": [
            "Breadth-First Search",
            "Binary First Search",
            "Best-Fit Search",
            "Backtracking Forward Search"
        ],
        "correctAnswer": 0,
        "explanation": "BFS stands for Breadth-First Search, which explores nodes level by level."
    },
    {
        "id": 398,
        "topic": "Graph",
        "algorithm": "BFS",
        "difficulty": "Easy",
        "question": "Which data structure is commonly used to implement BFS?",
        "options": [
            "Queue",
            "Stack",
            "Heap",
            "Disjoint Set"
        ],
        "correctAnswer": 0,
        "explanation": "BFS uses a queue to explore nodes in level order."
    },
    {
        "id": 399,
        "topic": "Graph",
        "algorithm": "DFS",
        "difficulty": "Easy",
        "question": "Which data structure is commonly used to implement DFS?",
        "options": [
            "Stack",
            "Queue",
            "Heap",
            "Priority Queue"
        ],
        "correctAnswer": 0,
        "explanation": "DFS uses a stack (explicit or via recursion) to explore nodes deeply before backtracking."
    },
    {
        "id": 400,
        "topic": "Graph",
        "algorithm": "DFS",
        "difficulty": "Easy",
        "question": "DFS can be implemented recursively. True or False?",
        "options": [
            "True",
            "False",
            "Only for trees",
            "Only for directed graphs"
        ],
        "correctAnswer": 0,
        "explanation": "DFS can be implemented recursively using function call stack or iteratively with an explicit stack."
    },
    {
        "id": 401,
        "topic": "Graph",
        "algorithm": "Dijkstra",
        "difficulty": "Easy",
        "question": "Dijkstra’s Algorithm is used to find:",
        "options": [
            "Shortest path from a source",
            "Minimum spanning tree",
            "All cycles in a graph",
            "Maximum flow"
        ],
        "correctAnswer": 0,
        "explanation": "Dijkstra’s Algorithm computes the shortest distance from a source node to all other vertices."
    },
    {
        "id": 402,
        "topic": "Graph",
        "algorithm": "Graph Comparison",
        "difficulty": "Easy",
        "question": "Which of the following correctly distinguishes a tree from a general graph?",
        "options": [
            "Tree has no cycles and is connected",
            "Tree may have cycles",
            "Tree can be disconnected",
            "Tree always has weighted edges"
        ],
        "correctAnswer": 0,
        "explanation": "A tree is an acyclic connected graph."
    },
    {
        "id": 403,
        "topic": "Graph",
        "algorithm": "Cycle Detection",
        "difficulty": "Easy",
        "question": "Which of the following indicates a cycle in an undirected graph using DFS?",
        "options": [
            "Visiting an already visited node not parent",
            "Visiting a node for the first time",
            "Finding a leaf node",
            "Counting number of edges"
        ],
        "correctAnswer": 0,
        "explanation": "A back edge to a visited node other than the parent indicates a cycle."
    },
    {
        "id": 404,
        "topic": "Graph",
        "algorithm": "BFS",
        "difficulty": "Easy",
        "question": "BFS is particularly suitable for finding:",
        "options": [
            "Shortest path in unweighted graphs",
            "Maximum flow",
            "Minimum spanning tree",
            "Topological order"
        ],
        "correctAnswer": 0,
        "explanation": "BFS finds the shortest path in graphs where all edges have equal weight."
    },
    {
        "id": 405,
        "topic": "Graph",
        "algorithm": "DFS",
        "difficulty": "Easy",
        "question": "DFS traversal of a graph may produce:",
        "options": [
            "Depth-first tree",
            "Breadth-first tree",
            "Minimum spanning tree",
            "Shortest path tree"
        ],
        "correctAnswer": 0,
        "explanation": "DFS generates a depth-first tree showing the order of node discovery."
    },
    {
        "id": 406,
        "topic": "Graph",
        "algorithm": "Dijkstra",
        "difficulty": "Easy",
        "question": "Dijkstra’s Algorithm does NOT work properly if:",
        "options": [
            "Graph has negative weight edges",
            "Graph has cycles",
            "Graph is disconnected",
            "Graph has multiple paths"
        ],
        "correctAnswer": 0,
        "explanation": "Dijkstra’s cannot handle negative weight edges correctly."
    },
    
    {
        "id": 407,
        "topic": "Graph",
        "algorithm": "BFS",
        "difficulty": "Medium",
        "question": "What is the time complexity of BFS in a graph with V vertices and E edges?",
        "options": [
            "O(V + E)",
            "O(V²)",
            "O(E log V)",
            "O(V E)"
        ],
        "correctAnswer": 0,
        "explanation": "BFS visits each vertex and edge once, giving O(V + E) complexity."
    },
    {
        "id": 408,
        "topic": "Graph",
        "algorithm": "DFS",
        "difficulty": "Medium",
        "question": "Time complexity of DFS on a graph with V vertices and E edges is:",
        "options": [
            "O(V + E)",
            "O(V²)",
            "O(E²)",
            "O(log V)"
        ],
        "correctAnswer": 0,
        "explanation": "DFS traverses all vertices and edges once, so time complexity is O(V + E)."
    },
    {
        "id": 409,
        "topic": "Graph",
        "algorithm": "Dijkstra",
        "difficulty": "Medium",
        "question": "Which data structure optimizes Dijkstra’s Algorithm for sparse graphs?",
        "options": [
            "Min-Heap",
            "Queue",
            "Stack",
            "Array"
        ],
        "correctAnswer": 0,
        "explanation": "Min-Heap helps efficiently pick the next vertex with minimum distance, reducing time on sparse graphs."
    },
    {
        "id": 410,
        "topic": "Graph",
        "algorithm": "Graph Comparison",
        "difficulty": "Medium",
        "question": "Which is true about directed and undirected graphs?",
        "options": [
            "Directed graph edges have direction, undirected do not",
            "Undirected graph edges have direction",
            "Directed graphs cannot have cycles",
            "Undirected graphs must be connected"
        ],
        "correctAnswer": 0,
        "explanation": "Directed graphs have edges with specific directions, while undirected graphs do not."
    },
    {
        "id": 411,
        "topic": "Graph",
        "algorithm": "Cycle Detection",
        "difficulty": "Medium",
        "question": "Which algorithm detects cycles in a directed graph efficiently?",
        "options": [
            "DFS with recursion stack",
            "BFS with queue",
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm"
        ],
        "correctAnswer": 0,
        "explanation": "DFS with recursion stack identifies back edges that form cycles in directed graphs."
    },
    {
        "id": 412,
        "topic": "Graph",
        "algorithm": "BFS",
        "difficulty": "Medium",
        "question": "In BFS, the level of a node represents:",
        "options": [
            "Shortest distance from source in unweighted graph",
            "Number of outgoing edges",
            "Depth in DFS tree",
            "Number of cycles containing node"
        ],
        "correctAnswer": 0,
        "explanation": "Level indicates how many edges are traversed from source to reach a node."
    },
    {
        "id": 413,
        "topic": "Graph",
        "algorithm": "DFS",
        "difficulty": "Medium",
        "question": "Which of the following is a key property of DFS?",
        "options": [
            "Can be used for topological sorting",
            "Always finds shortest paths",
            "Requires weighted edges",
            "Only works on trees"
        ],
        "correctAnswer": 0,
        "explanation": "DFS helps in applications like topological sorting, cycle detection, and connectivity checks."
    },
    {
        "id": 414,
        "topic": "Graph",
        "algorithm": "Dijkstra",
        "difficulty": "Medium",
        "question": "Dijkstra’s Algorithm produces a shortest path tree. What is true about this tree?",
        "options": [
            "Contains shortest paths from source to all vertices",
            "Contains longest paths",
            "Contains minimum spanning tree",
            "Contains only edges with weight 1"
        ],
        "correctAnswer": 0,
        "explanation": "The resulting tree gives shortest paths from the source to every reachable vertex."
    },
    {
        "id": 415,
        "topic": "Graph",
        "algorithm": "Graph Comparison",
        "difficulty": "Medium",
        "question": "Which of the following is a weighted graph?",
        "options": [
            "Graph with numbers on edges indicating cost",
            "Graph with only vertices",
            "Graph with colors on nodes",
            "Graph with direction on edges only"
        ],
        "correctAnswer": 0,
        "explanation": "Weighted graphs have numerical values (weights) assigned to edges."
    },
    {
        "id": 416,
        "topic": "Graph",
        "algorithm": "Cycle Detection",
        "difficulty": "Medium",
        "question": "Union-Find is typically used for cycle detection in which graph type?",
        "options": [
            "Undirected graph",
            "Directed graph",
            "Weighted graph only",
            "Tree only"
        ],
        "correctAnswer": 0,
        "explanation": "Union-Find efficiently checks for cycles in undirected graphs."
    },
    {
        "id": 417,
        "topic": "Graph",
        "algorithm": "BFS",
        "difficulty": "Hard",
        "question": "What is the space complexity of BFS on a graph with V vertices and E edges?",
        "options": [
            "O(V + E)",
            "O(V²)",
            "O(log V)",
            "O(E²)"
        ],
        "correctAnswer": 0,
        "explanation": "BFS requires space for the queue and visited set, giving O(V + E) space."
    },
    {
        "id": 418,
        "topic": "Graph",
        "algorithm": "DFS",
        "difficulty": "Hard",
        "question": "DFS can detect connected components in an undirected graph. True or False?",
        "options": [
            "True",
            "False",
            "Only if graph is weighted",
            "Only if graph is directed"
        ],
        "correctAnswer": 0,
        "explanation": "DFS explores all reachable vertices, which helps in counting connected components."
    },
    {
        "id": 419,
        "topic": "Graph",
        "algorithm": "Dijkstra",
        "difficulty": "Hard",
        "question": "Time complexity of Dijkstra’s Algorithm using min-heap is:",
        "options": [
            "O(E log V)",
            "O(V²)",
            "O(E + V)",
            "O(V log E)"
        ],
        "correctAnswer": 0,
        "explanation": "Using a min-heap, Dijkstra’s runs in O(E log V) time."
    },
    {
        "id": 420,
        "topic": "Graph",
        "algorithm": "Graph Comparison",
        "difficulty": "Hard",
        "question": "Which graph representation is best for sparse graphs?",
        "options": [
            "Adjacency List",
            "Adjacency Matrix",
            "Edge List",
            "Incidence Matrix"
        ],
        "correctAnswer": 0,
        "explanation": "Adjacency List uses less space for sparse graphs (O(V + E))."
    },
    {
        "id": 421,
        "topic": "Graph",
        "algorithm": "Cycle Detection",
        "difficulty": "Hard",
        "question": "Kahn’s Algorithm can detect cycles in which type of graph?",
        "options": [
            "Directed graph",
            "Undirected graph",
            "Weighted graph",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Kahn’s Algorithm checks for cycles in directed graphs by attempting topological sort."
    },
    {
        "id": 422,
        "topic": "Graph",
        "algorithm": "BFS",
        "difficulty": "Hard",
        "question": "In BFS, what can be used to reconstruct the shortest path from source to target?",
        "options": [
            "Parent array",
            "Visited set only",
            "Queue only",
            "Stack"
        ],
        "correctAnswer": 0,
        "explanation": "Parent array stores the predecessor of each node to reconstruct the path."
    },
    {
        "id": 423,
        "topic": "Graph",
        "algorithm": "DFS",
        "difficulty": "Hard",
        "question": "In DFS, discovery and finish times are useful for:",
        "options": [
            "Topological sorting and cycle detection",
            "Finding shortest path",
            "Calculating degree of vertices",
            "Finding maximum flow"
        ],
        "correctAnswer": 0,
        "explanation": "DFS timestamps are used in topological sort and identifying back edges for cycles."
    },
    {
        "id": 424,
        "topic": "Graph",
        "algorithm": "Dijkstra",
        "difficulty": "Hard",
        "question": "Which property of Dijkstra’s Algorithm ensures correctness in non-negative weighted graphs?",
        "options": [
            "Greedy selection of minimum distance vertex",
            "Using recursion",
            "Using stack",
            "Using BFS queue"
        ],
        "correctAnswer": 0,
        "explanation": "Dijkstra greedily selects the vertex with minimum distance at each step, ensuring correct shortest paths."
    },
    {
        "id": 425,
        "topic": "Graph",
        "algorithm": "Graph Comparison",
        "difficulty": "Hard",
        "question": "Adjacency matrix representation is efficient for which graph type?",
        "options": [
            "Dense graphs",
            "Sparse graphs",
            "Directed acyclic graphs only",
            "Trees only"
        ],
        "correctAnswer": 0,
        "explanation": "Adjacency matrices are efficient for dense graphs because all entries are used."
    },
    {
        "id": 426,
        "topic": "Graph",
        "algorithm": "Cycle Detection",
        "difficulty": "Hard",
        "question": "Which algorithm detects cycles in undirected graphs using Union-Find?",
        "options": [
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS only",
            "BFS only"
        ],
        "correctAnswer": 0,
        "explanation": "Kruskal’s Algorithm with Union-Find detects cycles by checking if vertices belong to the same set."
    },
    
    {
        "id": 427,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Easy",
        "question": "What is the primary goal of the KMP algorithm?",
        "options": [
            "To efficiently find a pattern in a text",
            "To count unique substrings in a string",
            "To compress large text files",
            "To generate random text patterns"
        ],
        "correctAnswer": 0,
        "explanation": "KMP efficiently finds occurrences of a pattern in a text by preprocessing the pattern to avoid redundant comparisons."
    },
    {
        "id": 428,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Easy",
        "question": "Which preprocessing table is used in KMP?",
        "options": [
            "LPS (Longest Prefix Suffix)",
            "Z Array",
            "Hash Table",
            "Prefix Sum Array"
        ],
        "correctAnswer": 0,
        "explanation": "The LPS array stores the longest proper prefix which is also a suffix, helping skip unnecessary comparisons."
    },
    {
        "id": 429,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Easy",
        "question": "Which technique is the basis of the Rabin-Karp algorithm?",
        "options": [
            "Hashing",
            "Divide and Conquer",
            "Dynamic Programming",
            "Greedy Method"
        ],
        "correctAnswer": 0,
        "explanation": "Rabin-Karp uses hashing to compare substring hashes efficiently instead of comparing character by character."
    },
    {
        "id": 430,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Easy",
        "question": "What is the average case time complexity of the Rabin-Karp algorithm?",
        "options": [
            "O(n + m)",
            "O(n*m)",
            "O(log n)",
            "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "Rabin–Karp performs in O(n + m) on average using efficient rolling hash updates."
    },
    {
        "id": 431,
        "topic": "String Algorithms",
        "algorithm": "Z Algorithm",
        "difficulty": "Easy",
        "question": "What does the Z array represent in the Z algorithm?",
        "options": [
            "The length of the longest substring starting at each position that matches the prefix",
            "Prefix sum values",
            "Hash codes of prefixes",
            "Number of unique substrings"
        ],
        "correctAnswer": 0,
        "explanation": "Each Z value represents how many characters from that position match the prefix of the string."
    },
    {
        "id": 432,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Easy",
        "question": "A suffix array is a sorted array of:",
        "options": [
            "All suffix indices of a string",
            "All prefixes of a string",
            "All unique characters",
            "All substrings of equal length"
        ],
        "correctAnswer": 0,
        "explanation": "A suffix array stores sorted indices of all suffixes of a string for efficient searching."
    },
    {
        "id": 433,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Easy",
        "question": "What is the time complexity of KMP in the worst case?",
        "options": [
            "O(n + m)",
            "O(n*m)",
            "O(log n)",
            "O(n^2)"
        ],
        "correctAnswer": 0,
        "explanation": "KMP guarantees linear time complexity by skipping redundant comparisons using the LPS table."
    },
    {
        "id": 434,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Easy",
        "question": "Why might Rabin-Karp produce false positives?",
        "options": [
            "Due to hash collisions",
            "Due to recursion errors",
            "Due to wrong pattern length",
            "Due to low memory"
        ],
        "correctAnswer": 0,
        "explanation": "Different substrings can yield the same hash value, leading to false positive matches."
    },
    {
        "id": 435,
        "topic": "String Algorithms",
        "algorithm": "Z Algorithm",
        "difficulty": "Easy",
        "question": "What is the time complexity of the Z algorithm?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n^2)",
            "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "The Z algorithm computes all Z values in O(n) time using an efficient window-based approach."
    },
    {
        "id": 436,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Easy",
        "question": "Which data structure is commonly used with a suffix array to find the longest repeated substring?",
        "options": [
            "LCP (Longest Common Prefix) array",
            "Z array",
            "Stack",
            "Binary Tree"
        ],
        "correctAnswer": 0,
        "explanation": "The LCP array stores lengths of longest common prefixes between adjacent suffixes in the suffix array."
    },
    {
        "id": 437,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Medium",
        "question": "How does the KMP algorithm handle mismatches efficiently?",
        "options": [
            "It uses the LPS array to skip comparisons",
            "It restarts the match from the beginning",
            "It hashes substrings again",
            "It reverses the pattern"
        ],
        "correctAnswer": 0,
        "explanation": "KMP uses the LPS array to determine how many characters can be skipped after a mismatch."
    },
    {
        "id": 438,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Medium",
        "question": "What type of hash function is typically used in Rabin-Karp?",
        "options": [
            "Rolling hash",
            "Static hash",
            "Cryptographic hash",
            "Prefix hash"
        ],
        "correctAnswer": 0,
        "explanation": "A rolling hash allows updating substring hashes in O(1) time as the window slides."
    },
    {
        "id": 439,
        "topic": "String Algorithms",
        "algorithm": "Z Algorithm",
        "difficulty": "Medium",
        "question": "How can the Z algorithm be used for pattern searching?",
        "options": [
            "Concatenate pattern + '$' + text and compute Z array",
            "Compute prefix sums of the text",
            "Reverse the pattern and compare",
            "Use recursion on substrings"
        ],
        "correctAnswer": 0,
        "explanation": "By concatenating pattern + '$' + text and computing Z values, matches are found where Z equals the pattern length."
    },
    {
        "id": 440,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Medium",
        "question": "Which sorting method helps build suffix arrays efficiently?",
        "options": [
            "Radix sort",
            "Bubble sort",
            "Heap sort",
            "Selection sort"
        ],
        "correctAnswer": 0,
        "explanation": "Radix sort enables efficient suffix array construction by sorting based on prefix ranks."
    },
    {
        "id": 441,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Medium",
        "question": "What is the space complexity of KMP?",
        "options": [
            "O(m)",
            "O(n)",
            "O(n + m)",
            "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "KMP uses O(m) space for storing the LPS array of the pattern."
    },
    {
        "id": 442,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Medium",
        "question": "How can hash collisions be minimized in Rabin-Karp?",
        "options": [
            "By using a large prime modulus and proper base",
            "By reversing the pattern",
            "By reducing text size",
            "By ignoring modulus operation"
        ],
        "correctAnswer": 0,
        "explanation": "Using a large prime modulus reduces hash collisions in rolling hash computations."
    },
    {
        "id": 443,
        "topic": "String Algorithms",
        "algorithm": "Z Algorithm",
        "difficulty": "Medium",
        "question": "What property makes the Z algorithm faster than naive pattern matching?",
        "options": [
            "It avoids re-comparing matched characters",
            "It hashes substrings",
            "It uses recursion",
            "It stores all substrings"
        ],
        "correctAnswer": 0,
        "explanation": "By maintaining a Z-box, the algorithm skips re-evaluating overlapping parts of matches."
    },
    {
        "id": 444,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Medium",
        "question": "Suffix arrays are often used as a space-efficient alternative to which structure?",
        "options": [
            "Suffix Trees",
            "Tries",
            "Stacks",
            "Heaps"
        ],
        "correctAnswer": 0,
        "explanation": "Suffix arrays use less space than suffix trees while providing similar functionality for substring operations."
    },
    {
        "id": 445,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Medium",
        "question": "In KMP, what does LPS[i] represent?",
        "options": [
            "Length of longest proper prefix which is also suffix for substring ending at i",
            "Longest repeated substring",
            "Length of palindrome centered at i",
            "Count of unique substrings"
        ],
        "correctAnswer": 0,
        "explanation": "LPS[i] stores the length of the longest proper prefix which is also a suffix up to index i."
    },
    {
        "id": 446,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Medium",
        "question": "What is the typical time complexity of building a suffix array using doubling?",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "correctAnswer": 0,
        "explanation": "Suffix arrays can be built in O(n log n) using prefix doubling with sorting."
    },
    {
        "id": 447,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Hard",
        "question": "What is the worst-case complexity of Rabin-Karp due to hash collisions?",
        "options": [
            "O(n*m)",
            "O(n + m)",
            "O(n log n)",
            "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "When hash collisions are frequent, Rabin-Karp may degrade to O(n*m) comparisons."
    },
    {
        "id": 448,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Hard",
        "question": "How does KMP perform when all characters in the pattern and text are the same?",
        "options": [
            "It still runs in O(n + m)",
            "It degrades to O(n*m)",
            "It requires hashing",
            "It terminates early"
        ],
        "correctAnswer": 0,
        "explanation": "KMP maintains linear time performance even for uniform strings due to its LPS optimization."
    },
    {
        "id": 449,
        "topic": "String Algorithms",
        "algorithm": "Z Algorithm",
        "difficulty": "Hard",
        "question": "How can Z algorithm help find the longest substring repeated twice?",
        "options": [
            "By taking maximum Z value with repetition",
            "By sorting suffixes",
            "By hashing substrings",
            "By comparing LCP values"
        ],
        "correctAnswer": 0,
        "explanation": "The maximum Z value represents the longest repeated prefix occurring elsewhere in the string."
    },
    {
        "id": 450,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Hard",
        "question": "How can a suffix array and LCP array be used to find the longest repeated substring?",
        "options": [
            "By finding the maximum LCP value",
            "By comparing first and last suffix",
            "By hashing suffixes",
            "By sorting LPS values"
        ],
        "correctAnswer": 0,
        "explanation": "The maximum value in the LCP array gives the length of the longest repeated substring."
    },
    {
        "id": 451,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Hard",
        "question": "Why is Rabin-Karp suitable for multiple pattern matching?",
        "options": [
            "It allows comparing multiple hashes simultaneously",
            "It skips hash computation",
            "It uses recursion for all patterns",
            "It sorts all substrings"
        ],
        "correctAnswer": 0,
        "explanation": "Rabin-Karp efficiently matches multiple patterns by storing and comparing multiple hash values."
    },
    {
        "id": 452,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Hard",
        "question": "What makes suffix arrays efficient for substring search?",
        "options": [
            "Binary search on sorted suffix indices",
            "Linear scan of suffixes",
            "Random hashing",
            "Prefix sums"
        ],
        "correctAnswer": 0,
        "explanation": "Since suffixes are lexicographically sorted, binary search can efficiently locate substring matches."
    },
    {
        "id": 453,
        "topic": "String Algorithms",
        "algorithm": "Z Algorithm",
        "difficulty": "Hard",
        "question": "Which is the space complexity of the Z algorithm?",
        "options": [
            "O(n)",
            "O(n^2)",
            "O(log n)",
            "O(1)"
        ],
        "correctAnswer": 0,
        "explanation": "The Z algorithm uses O(n) space to store the Z array for all positions."
    },
    {
        "id": 454,
        "topic": "String Algorithms",
        "algorithm": "KMP Algorithm",
        "difficulty": "Hard",
        "question": "What preprocessing step is required before using KMP?",
        "options": [
            "Computing the LPS array",
            "Building a suffix tree",
            "Creating a Z array",
            "Sorting prefixes"
        ],
        "correctAnswer": 0,
        "explanation": "KMP requires computing the LPS array before matching to enable efficient skips on mismatches."
    },
    {
        "id": 455,
        "topic": "String Algorithms",
        "algorithm": "Rabin-Karp Algorithm",
        "difficulty": "Hard",
        "question": "What happens if a small modulus is used in Rabin-Karp?",
        "options": [
            "More hash collisions occur",
            "The algorithm runs faster",
            "No effect on performance",
            "Pattern matching fails"
        ],
        "correctAnswer": 0,
        "explanation": "A small modulus leads to frequent hash collisions, reducing performance reliability."
    },
    {
        "id": 456,
        "topic": "String Algorithms",
        "algorithm": "Suffix Array",
        "difficulty": "Hard",
        "question": "Which algorithm can construct a suffix array in O(n) time?",
        "options": [
            "SA-IS algorithm",
            "KMP",
            "Rabin-Karp",
            "Merge Sort"
        ],
        "correctAnswer": 0,
        "explanation": "The SA-IS algorithm constructs a suffix array in O(n) time using induced sorting."
    },
    {
        "id": 457,
        "topic": "String Algorithms",
        "algorithm": "Z Algorithm",
        "difficulty": "Hard",
        "question": "In pattern matching using Z algorithm, what indicates a match?",
        "options": [
            "Z value equal to the pattern length",
            "Z value equal to zero",
            "Z value greater than text length",
            "Z value less than prefix length"
        ],
        "correctAnswer": 0,
        "explanation": "When Z value equals pattern length, it signifies a full match of the pattern at that position in the text."
    }

,
    {
        "id": 458,
        "topic": "Git",
        "algorithm": "Core Concepts",
        "difficulty": "Easy",
        "question": "Which command is used to initialize a new Git repository?",
        "options": [
            "git start",
            "git new",
            "git init",
            "git create"
        ],
        "correctAnswer": 2,
        "explanation": "`git init` creates a new Git repository in the current directory, setting up the necessary .git subdirectory."
    },
    {
        "id": 459,
        "topic": "Git",
        "algorithm": "Staging",
        "difficulty": "Easy",
        "question": "What command is used to stage a file for the next commit?",
        "options": [
            "git stage <file>",
            "git add <file>",
            "git track <file>",
            "git include <file>"
        ],
        "correctAnswer": 1,
        "explanation": "`git add <file>` adds the specified file's current content to the staging area (index), preparing it for the next commit."
    },
    {
        "id": 460,
        "topic": "Git",
        "algorithm": "Committing",
        "difficulty": "Easy",
        "question": "Which command saves your staged changes to the local repository history?",
        "options": [
            "git save",
            "git push",
            "git commit -m 'message'",
            "git store"
        ],
        "correctAnswer": 2,
        "explanation": "`git commit` takes the staged snapshot and permanently saves it to the project's history with a descriptive message."
    },
    {
        "id": 461,
        "topic": "Git",
        "algorithm": "Branching",
        "difficulty": "Medium",
        "question": "What is the command to create a new branch and switch to it immediately?",
        "options": [
            "git branch <name> && git checkout <name>",
            "git checkout -b <name>",
            "git new-branch <name>",
            "Both A and B are correct ways to do it"
        ],
        "correctAnswer": 3,
        "explanation": "`git checkout -b <name>` is a convenient shortcut that creates a new branch and switches to it in one step. The two separate commands also achieve the same result."
    },
    {
        "id": 462,
        "topic": "Git",
        "algorithm": "Remote",
        "difficulty": "Medium",
        "question": "What is the difference between `git fetch` and `git pull`?",
        "options": [
            "They are identical commands.",
            "`git pull` downloads remote changes but does not merge them.",
            "`git fetch` downloads remote changes but does not merge; `git pull` does both.",
            "`git fetch` pushes local changes to the remote."
        ],
        "correctAnswer": 2,
        "explanation": "`git fetch` retrieves the latest metadata from the remote but doesn't change your local working branch. `git pull` is equivalent to `git fetch` followed by `git merge`."
    },
    {
        "id": 463,
        "topic": "Git",
        "algorithm": "Merging",
        "difficulty": "Medium",
        "question": "What does `git rebase` do?",
        "options": [
            "It merges another branch into your current branch.",
            "It creates a new commit that combines the history of two branches.",
            "It moves or combines a sequence of commits to a new base commit.",
            "It deletes a branch."
        ],
        "correctAnswer": 2,
        "explanation": "Rebasing re-writes the project history by replaying commits from your current branch on top of another branch, creating a linear history."
    },
    {
        "id": 464,
        "topic": "Git",
        "algorithm": "History",
        "difficulty": "Hard",
        "question": "What is `git bisect` primarily used for?",
        "options": [
            "Splitting a large commit into smaller ones.",
            "Finding the specific commit that introduced a bug.",
            "Creating a backup of the repository.",
            "Merging two branches together."
        ],
        "correctAnswer": 1,
        "explanation": "`git bisect` uses a binary search algorithm to efficiently find the commit in your project's history that introduced a regression."
    },
    {
        "id": 465,
        "topic": "Git",
        "algorithm": "History",
        "difficulty": "Hard",
        "question": "What is the purpose of the `git reflog` command?",
        "options": [
            "To list all remote references.",
            "To log all changes to the repository's configuration.",
            "To show a log of where the HEAD and branch references have been.",
            "To format the `git log` output."
        ],
        "correctAnswer": 2,
        "explanation": "The reflog tracks every change to the tips of branches and other references in the repository. It's a safety net for recovering lost commits or undoing mistakes."
    },
    {
        "id": 466,
        "topic": "Git",
        "algorithm": "Core Concepts",
        "difficulty": "Hard",
        "question": "What does it mean to be in a 'detached HEAD' state in Git?",
        "options": [
            "The .git directory is corrupted.",
            "You have uncommitted changes in your working directory.",
            "HEAD is pointing directly to a commit instead of a branch.",
            "You are not connected to a remote repository."
        ],
        "correctAnswer": 2,
        "explanation": "A detached HEAD means HEAD refers to a specific commit, not a symbolic reference like a branch. This can happen when you check out a commit hash or a tag directly."
    },
    {
        "id": 467,
        "topic": "Git",
        "algorithm": "Staging",
        "difficulty": "Medium",
        "question": "Which command allows you to interactively stage parts of a changed file?",
        "options": [
            "git add -i",
            "git add -p",
            "git stage --interactive",
            "git commit --patch"
        ],
        "correctAnswer": 1,
        "explanation": "`git add -p` or `git add --patch` allows you to review and stage changes hunk by hunk within a file, giving you fine-grained control over your commits."
    },
    {
        "id": 468,
        "topic": "Git",
        "algorithm": "Committing",
        "difficulty": "Medium",
        "question": "How can you modify the most recent commit message?",
        "options": [
            "git commit --edit",
            "git rebase -i HEAD~1",
            "git commit --amend",
            "git log --edit"
        ],
        "correctAnswer": 2,
        "explanation": "`git commit --amend` opens your editor to let you change the commit message of the most recent commit. It can also be used to add forgotten files to the commit."
    },
    {
        "id": 469,
        "topic": "Git",
        "algorithm": "Staging",
        "difficulty": "Medium",
        "question": "Which command unstages a file (`file.txt`) but leaves the changes in the working directory?",
        "options": [
            "git reset HEAD file.txt",
            "git checkout -- file.txt",
            "git rm --cached file.txt",
            "git restore file.txt"
        ],
        "correctAnswer": 0,
        "explanation": "`git reset HEAD <file>` is the classic command to unstage a file. The more modern `git restore --staged <file>` also achieves this."
    },
    {
        "id": 470,
        "topic": "Git",
        "algorithm": "Branching",
        "difficulty": "Easy",
        "question": "How do you delete a local branch named 'feature-xyz'?",
        "options": [
            "git branch --delete feature-xyz",
            "git delete branch feature-xyz",
            "git branch -d feature-xyz",
            "git rm branch feature-xyz"
        ],
        "correctAnswer": 2,
        "explanation": "`git branch -d <branch-name>` deletes a local branch. Use `-D` to force delete if it has unmerged changes."
    },
    {
        "id": 471,
        "topic": "Git",
        "algorithm": "Branching",
        "difficulty": "Medium",
        "question": "What is the command to rename the current branch to 'new-name'?",
        "options": [
            "git rename branch new-name",
            "git branch -r new-name",
            "git branch -m new-name",
            "git checkout -r new-name"
        ],
        "correctAnswer": 2,
        "explanation": "`git branch -m <new-name>` renames the current branch. To rename a different branch, you can use `git branch -m <old-name> <new-name>`."
    },
    {
        "id": 472,
        "topic": "Git",
        "algorithm": "Branching",
        "difficulty": "Easy",
        "question": "Which command lists all local and remote branches?",
        "options": [
            "git branch --all",
            "git show-branches",
            "git list --branches",
            "git branch -lr"
        ],
        "correctAnswer": 0,
        "explanation": "`git branch -a` or `git branch --all` shows all local branches and remote-tracking branches."
    },
    {
        "id": 473,
        "topic": "Git",
        "algorithm": "Merging",
        "difficulty": "Medium",
        "question": "What is a 'merge conflict' in Git?",
        "options": [
            "When two branches have the same name.",
            "When Git cannot automatically resolve differences in code between two commits.",
            "An error that occurs when pushing to a remote repository.",
            "When a commit message is too long."
        ],
        "correctAnswer": 1,
        "explanation": "A merge conflict occurs when two branches have made competing changes to the same line of a file, and Git needs manual intervention to decide which change to keep."
    },
    {
        "id": 474,
        "topic": "Git",
        "algorithm": "Merging",
        "difficulty": "Hard",
        "question": "What does `git merge --squash feature-branch` do?",
        "options": [
            "Merges 'feature-branch' and creates a single commit on the current branch.",
            "Deletes 'feature-branch' after merging.",
            "Aborts the merge if there are conflicts.",
            "Performs a rebase instead of a merge."
        ],
        "correctAnswer": 0,
        "explanation": "`git merge --squash` takes all commits from the feature branch and 'squashes' them into a single set of changes in the staging area, allowing you to make a single new commit."
    },
    {
        "id": 475,
        "topic": "Git",
        "algorithm": "Rebasing",
        "difficulty": "Hard",
        "question": "What is the primary purpose of an interactive rebase (`git rebase -i`)?",
        "options": [
            "To merge two branches together.",
            "To view the history of a remote branch.",
            "To modify a sequence of commits (e.g., reword, squash, edit, reorder).",
            "To automatically resolve merge conflicts."
        ],
        "correctAnswer": 2,
        "explanation": "Interactive rebase is a powerful tool that allows you to clean up your commit history by rewording messages, squashing commits, editing files, or reordering commits before sharing them."
    },
    {
        "id": 476,
        "topic": "Git",
        "algorithm": "History",
        "difficulty": "Medium",
        "question": "Which `git log` command displays the history as a graph with commit hashes and messages on one line?",
        "options": [
            "git log --graph --pretty=oneline --abbrev-commit",
            "git log --chart",
            "git history --visual",
            "git log --tree"
        ],
        "correctAnswer": 0,
        "explanation": "This combination of flags provides a compact, graphical representation of the commit history, which is great for visualizing branches and merges."
    },
    {
        "id": 477,
        "topic": "Git",
        "algorithm": "History",
        "difficulty": "Easy",
        "question": "What does `git show <commit-hash>` display?",
        "options": [
            "Only the commit message.",
            "A list of all files in the repository at that commit.",
            "The metadata and content changes of the specified commit.",
            "The parent of the specified commit."
        ],
        "correctAnswer": 2,
        "explanation": "`git show` provides detailed information about a commit object, including the author, date, full commit message, and the diff of the changes introduced."
    },
    {
        "id": 478,
        "topic": "Git",
        "algorithm": "History",
        "difficulty": "Medium",
        "question": "How can you see the difference between your staged changes and the most recent commit?",
        "options": [
            "git diff",
            "git diff --staged",
            "git diff HEAD",
            "git status -v"
        ],
        "correctAnswer": 1,
        "explanation": "`git diff --staged` (or `git diff --cached`) shows the changes that are in the staging area, ready to be committed, compared to the `HEAD` commit."
    },
    {
        "id": 479,
        "topic": "Git",
        "algorithm": "Remote",
        "difficulty": "Hard",
        "question": "When is it generally acceptable to use `git push --force`?",
        "options": [
            "Whenever you have a merge conflict.",
            "Only on a personal feature branch that no one else is using.",
            "On shared branches like 'main' or 'develop' to fix mistakes.",
            "To upload large files."
        ],
        "correctAnswer": 1,
        "explanation": "Force pushing overwrites remote history and should be avoided on shared branches. It's acceptable on your own feature branches to clean up history before creating a pull request."
    },
    {
        "id": 480,
        "topic": "Git",
        "algorithm": "Remote",
        "difficulty": "Easy",
        "question": "Which command shows the URLs of your remote repositories?",
        "options": [
            "git remote -v",
            "git config --get remote.url",
            "git show remotes",
            "git remote url"
        ],
        "correctAnswer": 0,
        "explanation": "`git remote -v` (verbose) lists all your remote connections along with their fetch and push URLs."
    },
    {
        "id": 481,
        "topic": "Git",
        "algorithm": "Remote",
        "difficulty": "Medium",
        "question": "What is the main advantage of using `git pull --rebase` over a regular `git pull`?",
        "options": [
            "It is faster.",
            "It avoids creating a merge commit, maintaining a linear project history.",
            "It automatically resolves all conflicts.",
            "It pushes your changes to the remote immediately."
        ],
        "correctAnswer": 1,
        "explanation": "`git pull --rebase` fetches remote changes and replays your local commits on top of them, which helps avoid the extra merge commits that a standard `git pull` (fetch + merge) creates."
    },
    {
        "id": 482,
        "topic": "Git",
        "algorithm": "Stashing",
        "difficulty": "Medium",
        "question": "What is `git stash` used for?",
        "options": [
            "To permanently delete uncommitted changes.",
            "To temporarily save uncommitted changes so you can switch branches.",
            "To create a new commit with all current changes.",
            "To push changes directly to the remote."
        ],
        "correctAnswer": 1,
        "explanation": "`git stash` saves your modified tracked files and staged changes, then reverts the working directory to match the `HEAD` commit, allowing you to work on something else."
    },
    {
        "id": 483,
        "topic": "Git",
        "algorithm": "History",
        "difficulty": "Hard",
        "question": "Which command is used to apply a specific commit from one branch onto another?",
        "options": [
            "git apply <commit-hash>",
            "git rebase <commit-hash>",
            "git cherry-pick <commit-hash>",
            "git merge <commit-hash>"
        ],
        "correctAnswer": 2,
        "explanation": "`git cherry-pick` is used to take a single commit from one branch and apply it as a new commit on the current branch. It's useful for bringing a specific bug fix or feature to another branch."
    },
    {
        "id": 484,
        "topic": "Git",
        "algorithm": "Configuration",
        "difficulty": "Easy",
        "question": "How do you make Git ignore certain files or directories in your project?",
        "options": [
            "By adding them to a `.git/ignore` file.",
            "By using the `git ignore <file>` command.",
            "By listing them in a `.gitignore` file in the project's root directory.",
            "By deleting them from the repository."
        ],
        "correctAnswer": 2,
        "explanation": "The `.gitignore` file specifies intentionally untracked files that Git should ignore, such as build artifacts, log files, or environment-specific configuration."
    }



]
                                                        
