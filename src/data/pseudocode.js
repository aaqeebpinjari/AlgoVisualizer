// src/data/pseudocode.js
export const ALGORITHM_PSEUDOCODE = {
  bubbleSort: [
    { code: "for i from 0 to n-1", explain: "Repeat for each element in the array." },
    { code: "  for j from 0 to n-i-2", explain: "Compare each pair of adjacent elements." },
    { code: "    if arr[j] > arr[j+1]", explain: "Check if the current number is greater than the next number." },
    { code: "      swap arr[j] and arr[j+1]", explain: "Swap them if they are in the wrong order." },
  ],
  selectionSort: [
    { code: "for i from 0 to n-1", explain: "Repeat for each element in the array." },
    { code: "  minIdx = i", explain: "Assume the current position is the minimum." },
    { code: "  for j from i+1 to n-1", explain: "Check the rest of the array." },
    { code: "    if arr[j] < arr[minIdx]", explain: "If a smaller value is found, update minIdx." },
    { code: "  swap arr[i] and arr[minIdx]", explain: "Swap the smallest found with the current position." },
  ],
  insertionSort: [
    { code: "for i from 1 to n-1", explain: "Start from the second element." },
    { code: "  key = arr[i]", explain: "Store the current value." },
    { code: "  j = i - 1", explain: "Start comparing with previous elements." },
    { code: "  while j >= 0 and arr[j] > key", explain: "Move elements greater than key one position ahead." },
    { code: "    arr[j+1] = arr[j]", explain: "Shift the element right." },
    { code: "    j = j - 1", explain: "Move to the previous element." },
    { code: "  arr[j+1] = key", explain: "Insert the key at the correct position." },
  ],
  mergeSort: [
    { code: "if left < right", explain: "If the array has more than one element." },
    { code: "  mid = (left + right) / 2", explain: "Find the middle point." },
    { code: "  mergeSort(left, mid)", explain: "Sort the first half." },
    { code: "  mergeSort(mid+1, right)", explain: "Sort the second half." },
    { code: "  merge(left, mid, right)", explain: "Merge the sorted halves." },
  ],
  quickSort: [
    { code: "if low < high", explain: "If the array has more than one element." },
    { code: "  pivot = arr[high]", explain: "Select the rightmost element as pivot." },
    { code: "  partition(low, high)", explain: "Rearrange elements around the pivot." },
    { code: "  quickSort(low, pi - 1)", explain: "Recursively sort the left part." },
    { code: "  quickSort(pi + 1, high)", explain: "Recursively sort the right part." },
  ],
  radixSort: [
    { code: "max = getMax(arr)", explain: "Find the maximum number to get number of digits." },
    { code: "for digit = 1; max/digit > 0; digit *= 10", explain: "Process each digit from least to most significant." },
    { code: "  countingSort(arr, digit)", explain: "Sort by current digit using counting sort." },
    { code: "  distribute into buckets", explain: "Place numbers in buckets based on current digit." },
    { code: "  collect from buckets", explain: "Collect numbers back maintaining order." },
  ],
  bucketSort: [
    { code: "n = arr.length", explain: "Get the number of elements." },
    { code: "create n empty buckets", explain: "Create empty buckets for distribution." },
    { code: "for i = 0 to n-1", explain: "Process each element in the array." },
    { code: "  place in bucket by range", explain: "Distribute elements into appropriate buckets." },
    { code: "sort each bucket individually", explain: "Sort each bucket using insertion sort." },
    { code: "concatenate all buckets", explain: "Combine all sorted buckets to get final result." },
  ],
  heapSort: [
    { code: "buildMaxHeap(arr)", explain: "Rearrange the array to form a max-heap." },
    { code: "for i from n-1 down to 1", explain: "Iterate from the end of the heap." },
    { code: " swap arr[0] and arr[i]", explain: "Move the largest element (root) to the end." },
    { code: " heapify(arr, i, 0)", explain: "Restore the max-heap property on the reduced heap." },
  ],
  timSort: [
    { code: "minRun = calculateMinRun(n)", explain: "Compute the minimum run size (32–64 depending on n)." },
    { code: "for i from 0 to n step minRun", explain: "Process array in chunks of size minRun." },
    { code: "  end = min(i + minRun - 1, n-1)", explain: "Find the end index of the current run." },
    { code: "  insertionSort(arr, i, end)", explain: "Sort each small run with insertion sort." },
    { code: "size = minRun", explain: "Start merging from size = minRun." },
    { code: "while size < n", explain: "Double the size of runs until the array is sorted." },
    { code: "  for left from 0 to n-1 in steps of 2*size", explain: "Pick pairs of runs to merge." },
    { code: "    mid = left + size - 1", explain: "Find midpoint of the current run." },
    { code: "    right = min((left + 2*size - 1), n-1)", explain: "Find end of the right run." },
    { code: "    if mid < right", explain: "Check if two runs exist to merge." },
    { code: "      merge(arr, left, mid, right)", explain: "Merge the two runs like in merge sort." },
    { code: "  size = size * 2", explain: "Double the size and repeat merging." },
  ],
  cocktailShakerSort: [
  { code: "swapped = true", explain: "Initialize swapped to enter the loop." },
  { code: "start = 0", explain: "Set the starting index of the unsorted section." },
  { code: "end = n - 1", explain: "Set the ending index of the unsorted section." },
  { code: "while swapped", explain: "Continue sorting while a swap has occurred in the previous pass." },
  { code: "  swapped = false", explain: "Reset swapped flag before each forward pass." },
  { code: "  for i from start to end - 1", explain: "Forward pass: move larger elements towards the end." },
  { code: "    if arr[i] > arr[i+1] then swap(arr[i], arr[i+1])", explain: "Swap adjacent elements if they are out of order." },
  { code: "    swapped = true", explain: "Mark that a swap happened in this pass." },
  { code: "  if not swapped then break", explain: "If no swaps occurred in the forward pass, the array is sorted." },
  { code: "  swapped = false", explain: "Reset swapped before the backward pass." },
  { code: "  end = end - 1", explain: "Shrink the unsorted section from the end." },
  { code: "  for i from end - 1 down to start", explain: "Backward pass: move smaller elements towards the beginning." },
  { code: "    if arr[i] > arr[i+1] then swap(arr[i], arr[i+1])", explain: "Swap adjacent elements if needed during the backward pass." },
  { code: "    swapped = true", explain: "Mark that a swap happened in the backward pass." },
  { code: "  start = start + 1", explain: "Shrink the unsorted section from the start." }
],

  introSort: [
    { code: "maxDepth = 2 * log₂(n)", explain: "Set a recursion depth limit based on array size." },
    { code: "introSortHelper(arr, 0, n-1, maxDepth)", explain: "Start sorting with quicksort strategy." },
    { code: "if size < threshold", explain: "Use insertion sort for small subarrays." },
    { code: "else if depth == 0", explain: "If recursion depth is exhausted, switch to heapsort." },
    { code: "else", explain: "Otherwise, use quicksort partitioning with pivot." },
    { code: "  partition around pivot", explain: "Rearrange elements around pivot element." },
    { code: "  recursively sort left and right halves", explain: "Apply introsort recursively on partitions." },
    { code: "final insertion sort pass", explain: "Ensure small pieces are fully sorted at the end." },
  ],
  shellSort: [
    { code: "gap = n / 2", explain: "Start with a large gap (half the array size)." },
    { code: "while gap > 0", explain: "Keep reducing the gap until it becomes 1." },
    { code: "  for i from gap to n-1", explain: "Pick elements starting from the gap index." },
    { code: "    temp = arr[i]", explain: "Store the current element to be placed correctly." },
    { code: "    j = i", explain: "Initialize j to current index." },
    { code: "    while j >= gap and arr[j-gap] > temp", explain: "Shift earlier gap-sorted elements to the right." },
    { code: "      arr[j] = arr[j-gap]", explain: "Move the larger element up by one gap." },
    { code: "      j = j - gap", explain: "Move backwards by gap to keep checking." },
    { code: "    arr[j] = temp", explain: "Place the stored element in its correct position." },
    { code: "  gap = gap / 2", explain: "Reduce the gap for the next pass." },
  ],
  sleepSort: [
  { code: "for each number in array", explain: "Iterate through all elements of the array." },
  { code: "  start a timer for number × constant", explain: "Schedule a delayed action proportional to the element's value." },
  { code: "  after timer ends → output number", explain: "Smaller numbers finish earlier, so they appear first." },
  { code: "collect numbers in order of completion", explain: "As timers complete, elements are gathered in sorted order." },
  { code: "return sorted array", explain: "Final output is the array sorted in ascending order." },
],

  cycleSort: [
    { code: "for cycle_start in [0..n-2]", explain: "Choose cycle starting index" },
    { code: "item = arr[cycle_start]", explain: "Store the starting item" },
    { code: "pos = cycle_start", explain: "Find the correct position of item" },
    { code: "for i in [cycle_start+1..n-1]", explain: "Count smaller elements" },
    { code: "while item != arr[pos]", explain: "Swap and continue the cycle" },
    { code: "swap(item, arr[pos])", explain: "Place item at its correct position" },
  ],
  
  // ✅ NEW Counting Sort pseudocode
  countingSort: [
    { code: "find max and min elements", explain: "Determine the range of input elements." },
    { code: "range = max - min + 1", explain: "Calculate the size of the counting array." },
    { code: "initialize count array with zeros", explain: "Create an array to store counts of each element." },
    { code: "for each element in input array", explain: "Traverse the input array." },
    { code: "  count[element - min]++", explain: "Increment the count of the current element." },
    { code: "for i = 1 to range-1", explain: "Calculate cumulative counts." },
    { code: "  count[i] += count[i-1]", explain: "Modify count array to store actual positions." },
    { code: "for i = n-1 down to 0", explain: "Build the output array from right to left." },
    { code: "  output[count[input[i] - min] - 1] = input[i]", explain: "Place element at its correct position." },
    { code: "  count[input[i] - min]--", explain: "Decrease count for the next occurrence of the element." },
    { code: "copy output array to input array", explain: "Copy the sorted elements back to the original array." },
  ],

};